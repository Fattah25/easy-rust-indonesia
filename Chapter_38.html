<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> Closures - Easy Rust</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong> Updates</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong> Who am I?</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong> Catatan dari translator</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong> Writing Rust in Easy English</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong> Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong> üöß and ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong> Comments</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong> Types</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong> Type inference</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong> Printing 'hello, world!'</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong> Display and debug</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong> Mutability (changing)</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong> The stack, the heap, and pointers</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong> More about printing</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong> Strings</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong> const and static</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong> More on references</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong> Mutable references</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong> Giving references to functions</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong> Copy types</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong> Collection types</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong> Control flow</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong> Structs</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong> Enums</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong> Loops</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong> Implementing structs and enums</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong> Destructuring</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong> References and the dot operator</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong> Generics</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong> Option and Result</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong> Other collections</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong> The ? operator</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong> Traits</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong> Chaining methods</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="Chapter_38.html" class="active"><strong aria-hidden="true">39.</strong> Closures</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong> The dbg! macro and .inspect</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong> Types of &amp;str</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong> Cow</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong> The todo! macro</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong> Rc</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong> Multiple threads</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong> Closures in functions</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong> Arc</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong> Channels</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong> Reading Rust documentation</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong> Box</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong> Box around traits</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong> Default and the builder pattern</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong> Deref and DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong> Crates and modules</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong> Testing</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong> External crates</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong> A tour of the standard library</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong> Writing macros</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong> cargo</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong> Taking user input</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong> Using files</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="Chapter_67.html"><strong aria-hidden="true">68.</strong> The end?</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Easy Rust</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>Closures seperti bentuk pendek dari function yang tidak diberikan nama. Terkadang mereka juga disebut sebagai lambda. Closures sangat mudah ditemukan karena mereka menggunakan <code>||</code> daripada menggunakan <code>()</code>. Closure sangat umum digunakan di Rust, dan sekali Anda belajar untuk menggunakannya, Anda akan merasa ketergantungan untuk terus menggunakannya. :D</p>
<p>Anda bisa mengikat (bind) closure ke sebuah variable, dan kemudian saat Anda menggunakannya, ia terlihat persis seperti fungsi pada umumnya:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = || println!(&quot;This is a closure&quot;);
    my_closure();
}
</code></pre></pre>
<p>Jadi, closure yang di atas tidak mengambil apapun: <code>||</code> dan mencetak pesan: <code>This is a closure</code>.</p>
<p>Di antara <code>||</code> kita bisa menambahkan variabel input dan typenya, seperti yang kita tuliskan di antara <code>()</code> saat menuliskan sebuah function:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = |x: i32| println!(&quot;{}&quot;, x);

    my_closure(5);
    my_closure(5+5);
}
</code></pre></pre>
<p>Hasil cetaknya adalah:</p>
<pre><code class="language-text">5
10
</code></pre>
<p>Di saat closure menjadi lebih rumit, Anda bisa menambahkan code block. Maka ia bisa dituliskan sepanjang yang Anda inginkan.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_closure = || {
        let number = 7;
        let other_number = 10;
        println!(&quot;The two numbers are {} and {}.&quot;, number, other_number);
          // Closure ini bisa dibuat sepanjang yang Anda inginkan, sama seperti function.
    };

    my_closure();
}
</code></pre></pre>
<p>Tapi closure sangat spesial karena mereka bisa mengambil variabel yang berada di luar closure bahkan jika Anda hanya menuliskan <code>||</code>. Sehingga Anda bisa melakukan hal berikut ini:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = || println!(&quot;{}&quot;, number_one + number_two);
    my_closure();
}
</code></pre></pre>
<p>Program di atas mencetak <code>16</code>. Anda tidak perlu untuk menaruh apapun di antara <code>||</code> karena ia hanya mengambil <code>number_one</code> dan <code>number_two</code> dan menjumlahkannya.</p>
<p>Dari situlah nama <strong>closure</strong> berasal, karena ia mengambil variabel dan &quot;enclose&quot; (menyertakan) variabel tersebut di dalamny. Dan jika Anda menginginkan penjelahan yang lebih benar:</p>
<ul>
<li><code>||</code> yang tidak menyertakan variable dari luar adalah &quot;anonymous function&quot;. Anonymous artinya &quot;tidak memiliki nama&quot;. Ia bekerja mirip seperti function pada umumnya. Inilah yang biasanya disebut sebagai Lambda.</li>
<li><code>||</code> yang menyertakan variabel dari luar adalah &quot;closure&quot;. Ia &quot;encloses&quot;/&quot;menyertakan&quot; variabel di sekitarnya untuk digunakan.</li>
</ul>
<p>Tapi banyak orang biasa menyebut fungsi yang ditulis dengan <code>||</code> sebagai closure, jadi Anda tidak perlu khawatir apapun namanya. Kita akan menyebutnya sebagai &quot;closure&quot; untuk semua yang ditulis menggunakan <code>||</code>, tapi harus diingat bahwa itu juga bisa berarti adalah &quot;anonymous function&quot;/lambda.</p>
<p>Mengapa ada baiknya untuk mengetahui keduanya? Karena sebuah anonymous function sebenarnya membuat machine code yang sama sebagaimana function yang memiliki nama. Anonymous function terdengar seperti bahasa yang sangat tinggi, sehingga terkadang banyak orang berpikir bahwa machine codenya pastilah sangat rumit. Tetapi machine code yang dibuat Rust sama cepatnya seperti fungsi biasa.</p>
<p>Mari kita lihat beberapa hal lagi yang bisa dilakukan oleh closure. Anda juga bisa melakukan ini:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_one = 6;
    let number_two = 10;

    let my_closure = |x: i32| println!(&quot;{}&quot;, number_one + number_two + x);
    my_closure(5);
}
</code></pre></pre>
<p>Closure pada contoh di atas mengambil <code>number_one</code> dan <code>number_two</code>. Kita juga memberikannya variabel <code>x</code> dan mengatakan bahwa <code>x</code> adaalh 5. Kemudian menjumlahkan semua variabel tersebut untuk mencetak <code>21</code>.</p>
<p>Biasanya, Anda melihat closure di Rust di dalam method, karena closure memanglah sangat nyaman untuk digunakan. Kita melihat closure (di chapter sebelumnya) dengan <code>.map()</code> dan <code>.for_each()</code>. Di bagian dimana kita menuliskan <code>|x|</code> untuk memasukkan element berikutnya ke dalam iterator, dan itu adalah closure.</p>
<p>Ini adalah contoh lainnya: method <code>unwrap_or</code> yang telah kita ketahui sebelumnya, bisa Anda gunakan untuk meberikan value jika <code>unwrap</code> tidak berfungsi. Sebelumya, kita menuliskan: <code>let fourth = my_vec.get(3).unwrap_or(&amp;0);</code>. Tapi ada juga method <code>unwrap_or_else</code> yang memiliki closure di dalamnya. Sehingga Anda bisa menuliskannya seperti berikut:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    let fourth = my_vec.get(3).unwrap_or_else(|| { // mencoba untuk melakukan unwrap. Jika ia tidak berhasil,
        if my_vec.get(0).is_some() {               // periksa apakah my_vec memiliki sesuatu pada index [0]
            &amp;my_vec[0]                             // Berikan angka yang berada pada index ke-0 jika elementnya memang ada
        } else {
            &amp;0 // jika tidak ada, berikan &amp;0
        }
    });

    println!(&quot;{}&quot;, fourth);
}
</code></pre></pre>
<p>Tentu saja, closure bisa ditulis dengan sangat simple. Contohnya, Anda bisa menulis <code>let fourth = my_vec.get(3).unwrap_or_else(|| &amp;0);</code>. Anda tidak selalu harus menggunakan <code>{}</code> dan menuliskan code yang rumit hanya karena ia adalah sebuah closure. Asalkan Anda menuliskan <code>||</code>, compiler akan tahu bahwa Anda menggunakan closure.</p>
<p>Method closure yang paling sering digunakan, mungkin adalah <code>.map()</code>. Mari kita lihat lagi. Inilah salah satu cara untuk menggunakannya:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![2, 4, 6];

    let double_vec = num_vec        // ambil num_vec
        .iter()                     // lakukan iterasi pada vec tersebut
        .map(|number| number * 2)   // untuk setiap each item, kalikan dengan 2
        .collect::&lt;Vec&lt;i32&gt;&gt;();     // kemudian, buat sebuah Vec baru dari vec yang sudah di pass melalui chaining method
    println!(&quot;{:?}&quot;, double_vec);
}
</code></pre></pre>
<p>Contoh bagus lainnya adalah dengan <code>.for_each()</code> setelah <code>.enumerate()</code>. Method <code>.enumerate()</code> memberikan iterator dengan nomor index dan item/element. Sebagai contoh: <code>[10, 9, 8]</code> menjadi <code>(0, 10), (1, 9), (2, 8)</code>. Type untuk setiap elemenet ini adalah <code>(usize, i32)</code>. Sehingga Anda bisa melakukan hal ini:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()      // lakukan iterasi pada num_vec
        .enumerate() // ambil (index, number)
        .for_each(|(index, number)| println!(&quot;Index number {} has number {}&quot;, index, number)); // lakukan sesuatu untuk setiap hasil enumerate
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">Index number 0 has number 10
Index number 1 has number 9
Index number 2 has number 8
</code></pre>
<p>Pada contoh yang ini, kita menggunakan <code>for_each</code>, bukan <code>map</code>. <code>map</code> digunakan untuk <strong>melakukan sesuatu ke setiap item</strong> dan kemudian lakukan pass pada hasilnya. Sedangkan <code>for_each</code> adalah <strong>langsung melakukan sesuatu saat mendapatkan setiap item</strong>. Juga, <code>map</code> tidak melakukan apapun kecuali jika Anda menggunakan method seperti <code>collect</code>.</p>
<p>Sebenarnya, ada yang menarik dari iterator. Jika Anda mencoba untuk menggunakan <code>map</code> tanpa method seperti <code>collect</code>, compiler akan memberitahukan Anda bahwa ia tidak melakukan apapun. Ia tidak panic, namun compiler akan sekedar memberitahumu bahwa ia sama sekali tidak melakukan apapun.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 9, 8];

    num_vec
        .iter()
        .enumerate()
        .map(|(index, number)| println!(&quot;Index number {} has number {}&quot;, index, number));

}
</code></pre></pre>
<p>Compiler mengatakan:</p>
<pre><code class="language-text">warning: unused `std::iter::Map` that must be used
 --&gt; src\main.rs:4:5
  |
4 | /     num_vec
5 | |         .iter()
6 | |         .enumerate()
7 | |         .map(|(index, number)| println!(&quot;Index number {} has number {}&quot;, index, number));
  | |_________________________________________________________________________________________^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed
</code></pre>
<p>Ini merupakan <strong>warning</strong>, jadi ia bukanlah error: yang artinya, program tetap berjalan dengan baik meskipun ada teguran. Tapi mengapa num_vec tidak melakukan apapun? Kita bisa melihat typenya untuk mengetahui mengapa hal itu terjadi.</p>
<ul>
<li><code>let num_vec = vec![10, 9, 8];</code> Sekarang typenya adalah <code>Vec&lt;i32&gt;</code>.</li>
<li><code>.iter()</code> membuat typenya menjadi <code>Iter&lt;i32&gt;</code>. Sehingga sekarang typenya adalah iterator dengan element bertype <code>i32</code>.</li>
<li><code>.enumerate()</code> membuat typenya menjadi <code>Enumerate&lt;Iter&lt;i32&gt;&gt;</code>. Dan typenya menjadi <code>Enumerate</code> yang berasal dari <code>Iter</code> dengan element <code>i32</code>.</li>
<li><code>.map()</code> menjadikan typenya menjadi <code>Map&lt;Enumerate&lt;Iter&lt;i32&gt;&gt;&gt;</code>. Dan akhirnya menjadi type <code>Map</code> dari <code>Enumerate</code> yang berasal dari <code>Iter</code> dengan element<code>i32</code>.</li>
</ul>
<p>Apa yang kita lakukan membuat struktur dari typenya menjadi kompleks dan semakin kompleks. Sehingga <code>Map&lt;Enumerate&lt;Iter&lt;i32&gt;&gt;&gt;</code> ini adalah struktur yang siap digunakan, tetapi hanya jika kita memberi tahu apa yang harus dilakukan. Rust melakukan ini karena ia perlu menjalankan sesuatu dengan cepat. Rust tidak ingin melakukan hal seperti ini:</p>
<ul>
<li>iterasi semua <code>i32</code> yang berada di dalam Vec</li>
<li>kemudian enumerate <code>i32</code> yang berada dalam iterator</li>
<li>kemudiap map semua <code>i32</code> yang telah di-enumerate</li>
</ul>
<p>Rust hanya ingin melakukannya dalam 1 langkah, bukan 2, 3 ataupun berkali-kali seperti itu. Sehingga ia hanya membuat strukturnya saja dan menunggu struktur tersebut digunakan. Kemudian jika kita menuliskan <code>.collect::&lt;Vec&lt;i32&gt;&gt;()</code> ia tahu apa yang harus dilakukan, dan mulai mengerjakannya. Inilah apa yang dimaksud dengan <code>iterators are lazy and do nothing unless consumed</code>. Iterator tidak melakukan apapun sampai Anda &quot;mengkonsumsinya&quot; (menggunakannya).</p>
<p>Bahkan Anda bisa membuat sesuatu yang lumayan rumit seperti <code>HashMap</code> menggunakan <code>.collect()</code>, sehingga ia sangatlah powerful. Ini adalah contoh bagaimana menjadikan 2 buah vec menjadi <code>HashMap</code>. Pertama kita buat dua vector, dan kemudian akan kita gunakan <code>.into_iter()</code> pada vector tersebut untuk mendapatkan value dari iterator. Kemudian kita gunakan method <code>.zip()</code>. Method ini mengambil dua iterator dan menyatukannya, seperti zipper. Dan terakhir, kita gunakan <code>.collect()</code> untuk membuat <code>HashMap</code>.</p>
<p>Berikut ini adalah codenya:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // Vec&lt;i32&gt;
    let some_words = vec![&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]; // Vec&lt;&amp;str&gt;

    let number_word_hashmap = some_numbers
        .into_iter()                 // sekarang ia adalah iter
        .zip(some_words.into_iter()) // di dalam .zip() kita letakkan iter yang lain. Dan sekarang ia tergabung menjadi satu.
        .collect::&lt;HashMap&lt;_, _&gt;&gt;();

    println!(&quot;For key {} we get {}.&quot;, 2, number_word_hashmap.get(&amp;2).unwrap());
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">For key 2 we get two.
</code></pre>
<p>Anda bisa melihat bahwa kita menuliskan <code>&lt;HashMap&lt;_, _&gt;&gt;</code> karena itu adalah informasi yang cukup untuk Rust menentukan apa typenya (yaitu <code>HashMap&lt;i32, &amp;str&gt;</code>). Anda bisa menuliskan <code>.collect::&lt;HashMap&lt;i32, &amp;str&gt;&gt;();</code> jika Anda menginginkannya, atau Anda dapat menuliskannya seperti ini jika Anda mau:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let some_numbers = vec![0, 1, 2, 3, 4, 5]; // Vec&lt;i32&gt;
    let some_words = vec![&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]; // Vec&lt;&amp;str&gt;
    let number_word_hashmap: HashMap&lt;_, _&gt; = some_numbers  // Karena kita memberitahukan typenya disini...
        .into_iter()
        .zip(some_words.into_iter())
        .collect(); // maka kita tidak perlu menuliskannya disini
}
</code></pre></pre>
<p>Ada method lain seperti <code>.enumerate()</code> yang berguna untuk <code>char</code>, yaitu <code>char_indices()</code>. (Indices artinya &quot;banyak index&quot;). Anda menggunakannya dengan cara yang sama. Anggaplah kita memiliki string besar yang terbuat dari 3 digit angka.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers_together = &quot;140399923481800622623218009598281&quot;;

    for (index, number) in numbers_together.char_indices() {
        match (index % 3, number) {
            (0..=1, number) =&gt; print!(&quot;{}&quot;, number), // print angkanya jika masih ada sisanya
            _ =&gt; print!(&quot;{}\t&quot;, number), // sebaliknya, print angkanya menggunakan tab space
        }
    }
}
</code></pre></pre>
<p>Hasilnya adalah <code>140     399     923     481     800     622     623     218     009     598    281</code>.</p>
<h3 id="_-in-a-closure"><a class="header" href="#_-in-a-closure">|_| in a closure</a></h3>
<p>Terkadang Anda akan menemukan <code>|_|</code> pada sebuah closure. Ini artinya bahwa closure tersebut memerlukan argument/parameter (seperti <code>x</code>), tetapi Anda tidak ingin menggunakannya. Jadinya, <code>|_|</code> berarti &quot;Okay, closure ini mengambil argument, tapi saya tidak memberikannya nama karena saya tidak peduli tentang hal itu&quot;.</p>
<p>Ini adalah contoh dimana akan muncul error saat Anda tidak melakukan hal tersebut:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8, 9, 10];

    println!(&quot;{:?}&quot;, my_vec.iter().for_each(|| println!(&quot;We didn't use the variables at all&quot;))); // ‚ö†Ô∏è
}
</code></pre></pre>
<p>Rust akan memberikan pesan ini:</p>
<pre><code class="language-text">error[E0593]: closure is expected to take 1 argument, but it takes 0 arguments
  --&gt; src\main.rs:28:36
   |
28 |     println!(&quot;{:?}&quot;, my_vec.iter().for_each(|| println!(&quot;We didn't use the variables at all&quot;)));
   |                                    ^^^^^^^^ -- takes 0 arguments
   |                                    |
   |                                    expected closure that takes 1 argument
</code></pre>
<p>Compiler sebenarnya memberikan Anda bantuan/saran berupa pesan seperti berikut:</p>
<pre><code class="language-text">help: consider changing the closure to take and ignore the expected argument
   |
28 |     println!(&quot;{:?}&quot;, my_vec.iter().for_each(|_| println!(&quot;We didn't use the variables at all&quot;)));
</code></pre>
<p>Ini merupakan saran yang baik. Jika Anda mengganti <code>||</code> dengan <code>|_|</code> maka programnya akan berjalan.</p>
<h3 id="helpful-methods-for-closures-and-iterators"><a class="header" href="#helpful-methods-for-closures-and-iterators">Helpful methods for closures and iterators</a></h3>
<p>Rust akan menjadi bahasa yang menyenangkan untuk dipelajari setelah Anda merasa nyaman dengan closures. Dengan closure Anda bisa melakukan method berantai (chain method) satu sama lain dan melakukan banyak hal dengan code yang sangat sedikit. Berikut merupakan beberapa closure dan metode yang digunakan dengan closure yang belum kita lihat.</p>
<p><code>.filter()</code>: Ini memungkinkan Anda menyimpan item dalam iterator yang ingin Anda simpan. Mari kita filter bulan dalam setahun.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let months = vec![&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];

    let filtered_months = months
        .into_iter()                         // membuat sebuah iter
        .filter(|month| month.len() &lt; 5)     // Kita menginginkan nama bulan yang panjangnya kurang dari 5 bytes.
                                             // Kita tahu bahwa setiap huruf itu adalah 1 byte, sehingga kita bisa menggunakan .len()
        .filter(|month| month.contains(&quot;u&quot;)) // Juga kita hanya mencari nama bulan yang di dalamnya terdapat huruf u
        .collect::&lt;Vec&lt;&amp;str&gt;&gt;();

    println!(&quot;{:?}&quot;, filtered_months);
}
</code></pre></pre>
<p>Hasilnya adalah <code>[&quot;June&quot;, &quot;July&quot;]</code>.</p>
<p><code>.filter_map()</code>. Ia disebut <code>filter_map()</code> karena ia melakukan <code>.filter()</code> dan <code>.map()</code>. Closurenya haruslah mengembalikan <code>Option&lt;T&gt;</code>, dan kemudian <code>filter_map()</code> mengambil value untuk setiap <code>Option</code> jika ia adalah <code>Some</code>. Jadi, jika misalnya Anda melakukan <code>.filter_map()</code> pada <code>vec![Some(2), None, Some(3)]</code>, kembaliannya adalah <code>[2, 3]</code>.</p>
<p>Kita akan membuat contoh dengan struct <code>Company</code>. Setiap company memiliki field <code>name</code> yang bertype <code>String</code>, tapi CEO dari company tersebut mungkin saja baru saja keluar. Sehingga field <code>ceo</code> typenya adalah <code>Option&lt;String&gt;</code>. Kita akan menggunakan <code>.filter_map()</code> pada beberapa company untuk menyimpan nama CEOnya.</p>
<pre><pre class="playground"><code class="language-rust">struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            &quot;&quot; =&gt; None,
            name =&gt; Some(name.to_string()),
        }; // ceo ditentukan dengan match, dan kemudian kita return Self
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone() // return clone dari CEO (struct bukanlah Copy)
    }
}

fn main() {
    let company_vec = vec![
        Company::new(&quot;Umbrella Corporation&quot;, &quot;Unknown&quot;),
        Company::new(&quot;Ovintiv&quot;, &quot;Doug Suttles&quot;),
        Company::new(&quot;The Red-Headed League&quot;, &quot;&quot;),
        Company::new(&quot;Stark Enterprises&quot;, &quot;&quot;),
    ];

    let all_the_ceos = company_vec
        .into_iter()
        .filter_map(|company| company.get_ceo()) // filter_map memerlukan Option&lt;T&gt;
        .collect::&lt;Vec&lt;String&gt;&gt;();

    println!(&quot;{:?}&quot;, all_the_ceos);
}
</code></pre></pre>
<p>Hasilnya adalah <code>[&quot;Unknown&quot;, &quot;Doug Suttles&quot;]</code>.</p>
<p>Kita tahu bahwa <code>.filter_map()</code> memerlukan <code>Option</code>, bagaimana kalau <code>Result</code>? Tidak apa-apa: ada method bernama <code>.ok()</code> yang akan mengubah <code>Result</code> menjadi <code>Option</code>. Ia dinamakan <code>.ok()</code> karena semua yang ia kirimkan adalah result <code>Ok</code> (informasi <code>Err</code> dihilangkan). Kita ingat bahwa <code>Option</code> adalah <code>Option&lt;T&gt;</code>, sedangkan <code>Result</code> adalah <code>Result&lt;T, E&gt;</code> dengan informasi mengenai <code>Ok</code> dan juga <code>Err</code>. Jadi di saat Anda menggunakan <code>.ok()</code>, semua <code>Err</code> akan menghilang dan menjadi <code>None</code>.</p>
<p>Menggunakan <code>.parse()</code> adalah contoh mudah untuk hal ini, dimana kita mencoba untuk melakukan parse input dari user. <code>.parse()</code> ini akan mengambil <code>&amp;str</code> dan mencoba mengubahnya menjadi <code>f32</code>. Ia akan me-return <code>Result</code>, namun kita menggunakan <code>filter_map()</code>, jadi kita hanya membuang errornya saja. Semua yang <code>Err</code> akan dijadikan <code>None</code> dan selanjutnya akan difilter oleh <code>.filter_map()</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let user_input = vec![&quot;8.9&quot;, &quot;Nine point nine five&quot;, &quot;8.0&quot;, &quot;7.6&quot;, &quot;eleventy-twelve&quot;];

    let actual_numbers = user_input
        .into_iter()
        .filter_map(|input| input.parse::&lt;f32&gt;().ok())
        .collect::&lt;Vec&lt;f32&gt;&gt;();

    println!(&quot;{:?}&quot;, actual_numbers);
}
</code></pre></pre>
<p>Hasilnya adalah <code>[8.9, 8.0, 7.6]</code>.</p>
<p>Kebalikan dari <code>.ok()</code> adalah <code>.ok_or()</code> dan <code>ok_or_else()</code>. Ini akan mengubah <code>Option</code> menjadi <code>Result</code>. Ia disebut <code>.ok_or()</code> karena <code>Result</code> memberikan <code>Ok</code> <strong>or</strong> sebuah <code>Err</code>, sehingga perlu bagi Anda untuk memberikan apa value <code>Err</code>-nya nantinya. Ini dikarenakan <code>None</code> pada <code>Option</code> tidak memiliki informasi apapun. Juga, Anda bisa melihat bahwa bagian <em>else</em> pada nama method yang lainnya berarti bahwa ia memiliki closure.</p>
<p>Kita bisa mengambil <code>Option</code> dari struct <code>Company</code> dan mengubahnya menjadi <code>Result</code> dengan cara ini. Untuk error handling jangka panjang, ada baiknya apabila Anda membuat type error Anda sendiri. Namun untuk sekarang ini, kita cukup memberikannya pesan error, sehingga ia menjadi <code>Result&lt;String, &amp;str&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">// Semua yang ditulis sebelum main() masih sama seperti program sebelumnya
struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            &quot;&quot; =&gt; None,
            name =&gt; Some(name.to_string()),
        };
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone()
    }
}

fn main() {
    let company_vec = vec![
        Company::new(&quot;Umbrella Corporation&quot;, &quot;Unknown&quot;),
        Company::new(&quot;Ovintiv&quot;, &quot;Doug Suttles&quot;),
        Company::new(&quot;The Red-Headed League&quot;, &quot;&quot;),
        Company::new(&quot;Stark Enterprises&quot;, &quot;&quot;),
    ];

    let mut results_vec = vec![]; // Anggap saja kita perlu mengumpulkan hasil errornya juga

    company_vec
        .iter()
        .for_each(|company| results_vec.push(company.get_ceo().ok_or(&quot;No CEO found&quot;)));

    for item in results_vec {
        println!(&quot;{:?}&quot;, item);
    }
}
</code></pre></pre>
<p>Baris yang ini mengalami banyak perubahan:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
.for_each(|company| results_vec.push(company.get_ceo().ok_or(&quot;No CEO found&quot;)));
<span class="boring">}
</span></code></pre></pre>
<p>Ini artinya: &quot;untuk setiap company, gunakan <code>get_ceo()</code>. Jika Anda mendapatkannya, maka pass valuenya ke dalam <code>Ok</code>. dan jika Anda tidak mendapatkannya, pass  &quot;No CEO found&quot; ke dalam <code>Err</code>. Kemudian push <code>Result</code> tersebut ke dalam vec.&quot;</p>
<p>Sehingga, saat kita mencetak <code>results_vec</code>, kita mendapatkan ini:</p>
<pre><code class="language-text">Ok(&quot;Unknown&quot;)
Ok(&quot;Doug Suttles&quot;)
Err(&quot;No CEO found&quot;)
Err(&quot;No CEO found&quot;)
</code></pre>
<p>Sehingga kita sekarang memiliki 4 entry. Sekarang, mari kita coba <code>.ok_or_else()</code> agar kita bisa menggunakan closure dan mendapatkan pesan error yang lebih baik. Disini kita bisa menggunkan <code>format!</code> untuk membuat sebuah <code>String</code>, dan menaruh nama company di dalamnya. Kemudian kita return <code>String</code>-nya.</p>
<pre><pre class="playground"><code class="language-rust">// Semua yang ditulis sebelum main() masih sama seperti program sebelumnya
struct Company {
    name: String,
    ceo: Option&lt;String&gt;,
}

impl Company {
    fn new(name: &amp;str, ceo: &amp;str) -&gt; Self {
        let ceo = match ceo {
            &quot;&quot; =&gt; None,
            name =&gt; Some(name.to_string()),
        };
        Self {
            name: name.to_string(),
            ceo,
        }
    }

    fn get_ceo(&amp;self) -&gt; Option&lt;String&gt; {
        self.ceo.clone()
    }
}

fn main() {
    let company_vec = vec![
        Company::new(&quot;Umbrella Corporation&quot;, &quot;Unknown&quot;),
        Company::new(&quot;Ovintiv&quot;, &quot;Doug Suttles&quot;),
        Company::new(&quot;The Red-Headed League&quot;, &quot;&quot;),
        Company::new(&quot;Stark Enterprises&quot;, &quot;&quot;),
    ];

    let mut results_vec = vec![];

    company_vec.iter().for_each(|company| {
        results_vec.push(company.get_ceo().ok_or_else(|| {
            let err_message = format!(&quot;No CEO found for {}&quot;, company.name);
            err_message
        }))
    });

    for item in results_vec {
        println!(&quot;{:?}&quot;, item);
    }
}
</code></pre></pre>
<p>Hasil program tersebut adalah:</p>
<pre><code class="language-text">Ok(&quot;Unknown&quot;)
Ok(&quot;Doug Suttles&quot;)
Err(&quot;No CEO found for The Red-Headed League&quot;)
Err(&quot;No CEO found for Stark Enterprises&quot;)
</code></pre>
<p><code>.and_then()</code> adalah method yang sangat membantu yang mana ia akan mengambil <code>Option</code>, kemudian membuat Anda bisa melakukan sesuatu terhadap valuenya dan pass valuenya. Jadi, inputnya adalah <code>Option</code>, dan outputnya pula adalah <code>Option</code>. Ini sama seprti &quot;unwrap, kemudian lakukan sesuatu, kemudian wrap lagi&quot; dengan cara yang lebih aman.</p>
<p>Contoh mudahnya adalah sebuah angka yang kita dapatkan dari sebuah vec menggunakan <code>.get()</code>, karena kembaliannya adalah <code>Option</code>. Sekarang kita bisa melakukan pass valuenya ke <code>and_then()</code>, dan melakukan perhitungan matematis padanya jika ia adalah <code>Some</code>. Jika ia adalah <code>None</code>, maka <code>None</code> yang akan di-pass.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let new_vec = vec![8, 9, 0]; // vec yang berisi angka-angka

    let number_to_add = 5;       // gunakan ini untuk melakukan operasi matematis
    let mut empty_vec = vec![];  // resultnya akan dimasukkan ke sini


    for index in 0..5 {
        empty_vec.push(
            new_vec
               .get(index)
                .and_then(|number| Some(number + 1))
                .and_then(|number| Some(number + number_to_add))
        );
    }
    println!(&quot;{:?}&quot;, empty_vec);
}
</code></pre></pre>
<p>Hasil cetaknya adalah <code>[Some(14), Some(15), Some(6), None, None]</code>. Anda bisa melihat bahwa <code>None</code> tidak difilter (dibuang keluar), ia ikut di-pass ke dalam vector.</p>
<p><code>.and()</code> semacam <code>bool</code> pada <code>Option</code>. Anda bisa mencocokkan banyak <code>Option</code> ke <code>Option</code> yang lainnya, dan jika mereka semua adalah <code>Some</code> maka ia akan mengembalikan <code>Some</code> yang terakhir. Dan jika salah satunya adalah <code>None</code>, maka ia akan mengembalikan <code>None</code>.</p>
<p>Pertama-tama, ini adalah contoh <code>bool</code> untuk membantu Anda mendapatkan gambarannya. Anda bisa melihat bahwa jika Anda menggunakan <code>&amp;&amp;</code> (and), meskipun hanya ada satu <code>false</code> maka hasilnya akan <code>false</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let one = true;
    let two = false;
    let three = true;
    let four = true;

    println!(&quot;{}&quot;, one &amp;&amp; three); // prints true
    println!(&quot;{}&quot;, one &amp;&amp; two &amp;&amp; three &amp;&amp; four); // prints false
}
</code></pre></pre>
<p>Hal ini juga berlaku pada <code>.and()</code>. Bayangkan kita melakukan 5 operasi <code>.and()</code> dan menaruh hasilnya ke dalam Vec&lt;Option&lt;&amp;str&gt;&gt;.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let first_try = vec![Some(&quot;success!&quot;), None, Some(&quot;success!&quot;), Some(&quot;success!&quot;), None];
    let second_try = vec![None, Some(&quot;success!&quot;), Some(&quot;success!&quot;), Some(&quot;success!&quot;), Some(&quot;success!&quot;)];
    let third_try = vec![Some(&quot;success!&quot;), Some(&quot;success!&quot;), Some(&quot;success!&quot;), Some(&quot;success!&quot;), None];

    for i in 0..first_try.len() {
        println!(&quot;{:?}&quot;, first_try[i].and(second_try[i]).and(third_try[i]));
    }
}
</code></pre></pre>
<p>Program di atas akan menunjukkan index mana saja yang selalu mendapatkan <code>Some</code> dari 3 vec tersebut. Hasilnya adalah:</p>
<pre><code class="language-text">None
None
Some(&quot;success!&quot;)
Some(&quot;success!&quot;)
None
</code></pre>
<p>Pada index ke-0 hasilnya adalah <code>None</code> karena ada <code>None</code> pada index ke-0 di vec <code>second_try</code>. Index ke-1 adalah <code>None</code> karena ada <code>None</code> pada vec <code>first_try</code>. Selanjutnya, hasilnya adalah <code>Some(&quot;success!&quot;)</code> karena tidak ada <code>None</code> pada vec <code>first_try</code>, <code>second try</code>, ataupun <code>third_try</code>.</p>
<p><code>.any()</code> dan <code>.all()</code> sangat mudah digunakan dalam iterator. Ia mengembalikan <code>bool</code> tergantung dari inputan Anda. Pada contoh ini kita membuat vec yang sangat besar (sekitar 20,000 item/element) dengan menggunakan karakter dari <code>'a'</code> sampai <code>'ÂÉç'</code>. Kemudian kita buat sebuah function untuk memeriksa apakah ada karakter di dalamnya.</p>
<p>selanjutnya kita buat sebuah vec yang lebih kecil and dan memeriksa apakah semuanya adalah alphabet (dengan menggunakan method <code>.is_alphabetic()</code>). Kemudian kita tanyakan apakah semua karakter kurang dari karakter Korea <code>'Ìñâ'</code>.</p>
<p>Perhatikan juga bahwa Anda menggunakan reference, karena <code>.iter()</code> memberikan reference dan Anda menggunakan <code>&amp;</code> untuk dibandingkan dengan <code>&amp;</code> lainnya.</p>
<pre><pre class="playground"><code class="language-rust">fn in_char_vec(char_vec: &amp;Vec&lt;char&gt;, check: char) {
    println!(&quot;Is {} inside? {}&quot;, check, char_vec.iter().any(|&amp;char| char == check)); // reference destructure 
}

fn main() {
    let char_vec = ('a'..'ÂÉç').collect::&lt;Vec&lt;char&gt;&gt;();
    in_char_vec(&amp;char_vec, 'i');
    in_char_vec(&amp;char_vec, 'Î∑Å');
    in_char_vec(&amp;char_vec, 'Èëø');

    let smaller_vec = ('A'..'z').collect::&lt;Vec&lt;char&gt;&gt;();
    println!(&quot;All alphabetic? {}&quot;, smaller_vec.iter().all(|&amp;x| x.is_alphabetic())); // reference destructure 
    println!(&quot;All less than the character Ìñâ? {}&quot;, smaller_vec.iter().all(|&amp;x| x &lt; 'Ìñâ')); // reference destructure 
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">Is i inside? true
Is Î∑Å inside? false
Is Èëø inside? false
All alphabetic? false
All less than the character Ìñâ? true
</code></pre>
<p>Ah ya, <code>.any()</code> hanya memeriksa sampai menemukan satu item yang cocok, lalu berhenti. Ia tidak akan memeriksa semuanya jika sudah menemukan kecocokan. Jika Anda menggunakan <code>.any()</code> pada <code>Vec</code>, mungkin adalah ide yang bagus untuk push item yang mungkin cocok ke bagian depan. Atau Anda bisa menggunakan <code>.rev()</code> setelah <code>.iter()</code> untuk me-reverse (membalik) iteratornya. Contohnya seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);
}
</code></pre></pre>
<p><code>Vec</code> di atas memilik 1000 buah <code>6</code> yang kemudian diisi dengan sebuah <code>5</code>. Anggap saja kita ingin menggunakan <code>.any()</code> untuk melihat apakah ia berisi 5. Pertama, kita pastikan dulu bahwa <code>.rev()</code> berjalan dengan benar. Diingat lagi, sebuah <code>Iterator</code> selalu memiliki <code>.next()</code> yang memungkinkan Anda memeriksa apa yang dilakukannya setiap saat.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    let mut iterator = big_vec.iter().rev();
    println!(&quot;{:?}&quot;, iterator.next());
    println!(&quot;{:?}&quot;, iterator.next());
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">Some(5)
Some(6)
</code></pre>
<p>Yup, program kita berjalan dengan benar. Ada satu <code>Some(5)</code> dan 1000 <code>Some(6)</code> setelahnya. Jadinya kita menulisnya seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    println!(&quot;{:?}&quot;, big_vec.iter().rev().any(|&amp;number| number == 5));
}
</code></pre></pre>
<p>Dan karena ia menggunakan <code>.rev()</code>, ia hanya memanggil <code>.next()</code> sekali saja dan berhenti. Jika kita tidak menggunakan <code>.rev()</code> maka ia akan memanggil <code>.next()</code> 1001 kali sebelum programnya berhenti. Codenya seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut big_vec = vec![6; 1000];
    big_vec.push(5);

    let mut counter = 0; // Mulai menghitung
    let mut big_iter = big_vec.into_iter(); // ubah big_vec menjadi Iterator

    loop {
        counter +=1;
        if big_iter.next() == Some(5) { // tetap memanggil .next() sampai kita mendapatkan Some(5)
            break;
        }
    }
    println!(&quot;Final counter is: {}&quot;, counter);
}
</code></pre></pre>
<p>Hasilnya adalah <code>Final counter is: 1001</code>, sehingga kita tahu bahwa ia akan memanggil <code>.next()</code> 1001 kali sebelum ia menemukan 5.</p>
<p><code>.find()</code> memberitahu kita jika iterator memiliki sesuatu, dan <code>.position()</code> memberi tahu kita dimana lokasinya. <code>.find()</code> berbeda dari <code>.any()</code> karena ia mengembalikan <code>Option</code> dengan value di dalamnya (atau <code>None</code>). Sedangkan <code>.position()</code> juga adalah <code>Option</code> beserta angka yang merepresentasikan posisinya, atau <code>None</code>. Dengan kata lain:</p>
<ul>
<li><code>.find()</code>: &quot;Saya akan mencoba mencarikannya untuk Anda&quot;</li>
<li><code>.position()</code>: &quot;Saya akan mencoba menemukan dimana tempatnya untuk Anda&quot;</li>
</ul>
<p>Berikut adalah contohnya:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100];

    println!(&quot;{:?}&quot;, num_vec.iter().find(|&amp;number| number % 3 == 0)); // method find mengambil reference, sehingga kita berikan ia &amp;number
    println!(&quot;{:?}&quot;, num_vec.iter().find(|&amp;number| number * 2 == 30));

    println!(&quot;{:?}&quot;, num_vec.iter().position(|&amp;number| number % 3 == 0));
    println!(&quot;{:?}&quot;, num_vec.iter().position(|&amp;number| number * 2 == 30));

}
</code></pre></pre>
<p>Ia akan mencetak:</p>
<pre><code class="language-text">Some(30) // This is the number itself
None // No number inside times 2 == 30
Some(2) // This is the position
None
</code></pre>
<p>Dengan menggunakan <code>.cycle()</code> Anda bisa membuat iterator yang terus menerus melakukan loop. Iterator seperti ini bekerja dengan baik dengan method <code>.zip()</code> untuk membuat sesuatu yang baru, seperti pada contoh ini yang mana akan membuat <code>Vec&lt;(i32, &amp;str)&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let even_odd = vec![&quot;even&quot;, &quot;odd&quot;];

    let even_odd_vec = (0..6)
        .zip(even_odd.into_iter().cycle())
        .collect::&lt;Vec&lt;(i32, &amp;str)&gt;&gt;();
    println!(&quot;{:?}&quot;, even_odd_vec);
}
</code></pre></pre>
<p>Jadi meskipun method <code>.cycle()</code> semestinya tidak berhenti, iterator yang lain hanya menjalankannya 6 kali di saat melakukan zip antara vec <code>even_odd</code> dan iterator <code>0..6</code>. Itu berarti bahwa iterator yang dibuat oleh <code>.cycle()</code> tidak lagi memanggil <code>.next()</code>, sehingga ia selesai setelah dipanggil sebanyak 6 kali. Outputnya adalah seperti berikut:</p>
<pre><code>[(0, &quot;even&quot;), (1, &quot;odd&quot;), (2, &quot;even&quot;), (3, &quot;odd&quot;), (4, &quot;even&quot;), (5, &quot;odd&quot;)]
</code></pre>
<p>Hal serupa dapat dilakukan dengan pada range yang tidak memiliki akhir. Jika Anda menuliskan <code>0..</code> maka Anda membuat sebuah range yang tidak berhenti. Anda bisa menggunakannya dengan sangat mudah, seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let ten_chars = ('a'..).take(10).collect::&lt;Vec&lt;char&gt;&gt;();
    let skip_then_ten_chars = ('a'..).skip(1300).take(10).collect::&lt;Vec&lt;char&gt;&gt;();

    println!(&quot;{:?}&quot;, ten_chars);
    println!(&quot;{:?}&quot;, skip_then_ten_chars);
}
</code></pre></pre>
<p>Keduanya akan mencetak 10 characters, namun pada cetakan kedua ia melakukan skip sebanyak 1300, dan mencetak 10 huruf dalam aksara Armenia.</p>
<pre><code>['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']
['’µ', '’∂', '’∑', '’∏', '’π', '’∫', '’ª', '’º', '’Ω', '’æ']
</code></pre>
<p>Method terkenal lainnya adalah <code>.fold()</code>. Method ini sering digunakan untuk menjumlahkan elemen-elemen yang berada di dalam iterator, tapi tidak hanya itu saja, Anda juga bisa melakukan hal lain. Method ini mirip dengan <code>.for_each()</code>. Pada <code>.fold()</code>, Pertama-tama Anda menambahkan value awalan (jika Anda ingin menjumlahkan setiap element, maka valuenya 0), kemudian tuliskan koma, dan selanjutnya tuliskan closure. Closure memberikan Anda 2 hal, yaitu total (yang dihitung sejauh iterator dijalankan), dan element selanjutnya. Dibawah ini adalah contoh menggunakan <code>.fold()</code> untuk menjumlahkan setiap element di dalam vec.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_numbers = vec![9, 6, 9, 10, 11];

    println!(&quot;{}&quot;, some_numbers
        .iter()
        .fold(0, |total_so_far, next_number| total_so_far + next_number)
    );
}
</code></pre></pre>
<p>Jadi, berikut penjelasannya:</p>
<ul>
<li>Pada langkah 1, ia dimulai dengan 0 dan menambahkannya dengan angka selanjutnya, yaitu 9.</li>
<li>Kemudian diambillah 9 dan ditambahkan dengan element selanjutnya, yaitu 6: totalnya 15.</li>
<li>Kemudian diambillah 15, dan ditambahkan dengan element selanjutnya, yaitu 9: totalnya 24.</li>
<li>Kemudian diambillah 24, dan ditambahkan dengan element selanjutnya, yaitu 10: totalnya 34.</li>
<li>Dan terakhir, diambillah 34, dan ditambahkan dengan 11: sehingga hasil akhirnya adalah 45. Jadinya ia akan mencetak <code>45</code>.</li>
</ul>
<p>Tidak hanya untuk hal seperti itu, ini adalah contoh dimana kita bisa menambahakan '-' ke setiap karakter untuk membuat <code>String</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a_string = &quot;I don't have any dashes in me.&quot;;

    println!(
        &quot;{}&quot;,
        a_string
            .chars() // sekarang ia sudah menjadi iterator
            .fold(&quot;-&quot;.to_string(), |mut string_so_far, next_char| { // mulai dengan String &quot;-&quot;. Jadiak ia sebagai mutable setiap saat bersama dengan karakter berikutnya
                string_so_far.push(next_char); // Push terlebih dahulu charnya, kemudian '-'
                string_so_far.push('-');
                string_so_far} // Jangan lupa untuk pass hasilnya ke loop selanjutnya
            ));
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">-I- -d-o-n-'-t- -h-a-v-e- -a-n-y- -d-a-s-h-e-s- -i-n- -m-e-.-
</code></pre>
<p>Dan masih banyak method yang mudah untuk digunakan seperti:</p>
<ul>
<li><code>.take_while()</code> yang mana akan mengambil value dari iterator selama kondisinya selalu <code>true</code> (contohnya <code>take while x &gt; 5</code>)</li>
<li><code>.cloned()</code> yang mana akan membuat clone didalam iterator.Ini akan mengubah reference menjadi value.</li>
<li><code>.by_ref()</code> yang mana membuat sebuah iterator mengambil reference. Ini bagus untuk memastikan bahwa Anda bisa menggunakan sebuah <code>Vec</code> (atau sesuatu yang serupa) setelah Anda menggunakannya untuk membuat iterator.</li>
<li>Method <code>_while</code> lainnya: <code>.skip_while()</code>, <code>.map_while()</code>, dan seterusnya</li>
<li><code>.sum()</code>: menjumlahkan apapun yang ada di dalamnya.</li>
</ul>
<p><code>.chunks()</code> dan <code>.windows()</code> adalah dua cara untuk memotong vector menjadi ukuran sesuai yang Anda inginkan. Anda tuliskan ukuran yang Anda inginkan di dalam bracket. Katakanlah, Anda memiliki vector yang berisi 10 item, dan Anda ingin ukurannya adalah 3. Ia akan bekerja seperti ini:</p>
<ul>
<li>
<p><code>.chunks()</code> akan memberikanmu 4 potong: [0, 1, 2], kemudian [3, 4, 5], kemudian [6, 7, 8], dan terakhir [9]. Jadinya, ia akan mencoba untuk membuat sebuah potongan dari 3 item, tapi jika ia tidak mencapai 3 buah, ia tidak panic. Ia hanya akan memberi apa yang tersisa.</p>
</li>
<li>
<p><code>.windows()</code> pertama-tama akan memberimu potongan [0, 1, 2]. Kemudian ia akan berpindah maju selangkah dan memberi Anda potongan [1, 2, 3]. Ia akan melakukan itu sampai akhirnya ia mencapai potongan terakhir yang anggotanya 3 item, dan kemudian berhenti.</p>
</li>
</ul>
<p>So let's use them on a simple vector of numbers. It looks like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num_vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 0];

    for chunk in num_vec.chunks(3) {
        println!(&quot;{:?}&quot;, chunk);
    }
    println!();
    for window in num_vec.windows(3) {
        println!(&quot;{:?}&quot;, window);
    }
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
[0]

[1, 2, 3]
[2, 3, 4]
[3, 4, 5]
[4, 5, 6]
[5, 6, 7]
[6, 7, 8]
[7, 8, 9]
[8, 9, 0]
</code></pre>
<p>Perlu diketahui, <code>.chunks()</code> akan panic jika Anda tidak memberikannya apapun. Anda bisa menulis <code>.chunks(1000)</code> untuk sebuah vector yang hanya memiliki satu item, tapi Anda tidak bisa menulis <code>.chunks()</code> dengan sesuatu yang panjangnya 0.</p>
<p><code>.match_indices()</code> memungkinkan Anda menarik semua yang ada di dalam sebuah <code>String</code> atau <code>&amp;str</code> yang cocok dengan input yang Anda berikan, dan ia akan memberikan Anda indexnya juga. Ini mirip seperti <code>.enumerate()</code> karena ia memberikan return berupa tuple yang berisi dua item.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rules = &quot;Rule number 1: No fighting. Rule number 2: Go to bed at 8 pm. Rule number 3: Wake up at 6 am.&quot;;
    let rule_locations = rules.match_indices(&quot;Rule&quot;).collect::&lt;Vec&lt;(_, _)&gt;&gt;(); // Ini adalah Vec&lt;usize, &amp;str&gt;, tapi kita biarkan Rust yang akan menentukannya
    println!(&quot;{:?}&quot;, rule_locations);
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">[(0, &quot;Rule&quot;), (28, &quot;Rule&quot;), (62, &quot;Rule&quot;)]
</code></pre>
<p><code>.peekable()</code> memungkinkan Anda membuat iterator di mana Anda dapat melihat (mengintip) item berikutnya. Ini seperti memanggil <code>.next()</code> (yang mana ia akan memberikan <code>Option</code>), hanya saja iteratornya tidak bergerak, sehingga Anda dapat menggunakannya sebanyak yang Anda inginkan. Anda sebenarnya dapat menganggap peekable ini sebagai &quot;stoppable&quot;, karena Anda dapat berhenti selama yang Anda inginkan. Berikut adalah contoh dimana kita menggunakan <code>.peek()</code> tiga kali pada setiap item. Kita bisa menggunakan <code>.peek()</code> selamanya sampai kita menggunakan <code>.next()</code> untuk pindah ke item berikutnya.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let just_numbers = vec![1, 5, 100];
    let mut number_iter = just_numbers.iter().peekable(); // Ini sebenarnya membuat type iterator yang biasa disebut sebagai Peekable

    for _ in 0..3 {
        println!(&quot;I love the number {}&quot;, number_iter.peek().unwrap());
        println!(&quot;I really love the number {}&quot;, number_iter.peek().unwrap());
        println!(&quot;{} is such a nice number&quot;, number_iter.peek().unwrap());
        number_iter.next();
    }
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">I love the number 1
I really love the number 1
1 is such a nice number
I love the number 5
I really love the number 5
5 is such a nice number
I love the number 100
I really love the number 100
100 is such a nice number
</code></pre>
<p>Ini adalah contoh lain dimana kita menggunakan <code>.peek()</code> untuk mencocokka sebuah item. Setelah kita selesai menggunakannya, kita panggil <code>.next()</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let locations = vec![
        (&quot;Nevis&quot;, 25),
        (&quot;Taber&quot;, 8428),
        (&quot;Markerville&quot;, 45),
        (&quot;Cardston&quot;, 3585),
    ];
    let mut location_iter = locations.iter().peekable();
    while location_iter.peek().is_some() {
        match location_iter.peek() {
            Some((name, number)) if *number &lt; 100 =&gt; { // .peek() memberikan kita reference, sehingga kita memerlukan *
                println!(&quot;Found a hamlet: {} with {} people&quot;, name, number)
            }
            Some((name, number)) =&gt; println!(&quot;Found a town: {} with {} people&quot;, name, number),
            None =&gt; break,
        }
        location_iter.next();
    }
}
</code></pre></pre>
<p>Outputnya:</p>
<pre><code class="language-text">Found a hamlet: Nevis with 25 people
Found a town: Taber with 8428 people
Found a hamlet: Markerville with 45 people
Found a town: Cardston with 3585 people
</code></pre>
<p>Dan terakhir, ini adalah contoh dimana kita juga bisa menggunakan <code>.match_indices()</code>. Pada contoh ini, kita meletakkan nama ke dalam <code>struct</code> tergantung pada jumlah spasi di <code>&amp;str</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Names {
    one_word: Vec&lt;String&gt;,
    two_words: Vec&lt;String&gt;,
    three_words: Vec&lt;String&gt;,
}

fn main() {
    let vec_of_names = vec![
        &quot;Caesar&quot;,
        &quot;Frodo Baggins&quot;,
        &quot;Bilbo Baggins&quot;,
        &quot;Jean-Luc Picard&quot;,
        &quot;Data&quot;,
        &quot;Rand Al'Thor&quot;,
        &quot;Paul Atreides&quot;,
        &quot;Barack Hussein Obama&quot;,
        &quot;Bill Jefferson Clinton&quot;,
    ];

    let mut iter_of_names = vec_of_names.iter().peekable();

    let mut all_names = Names { // buat sebuah struct Names yang kosong
        one_word: vec![],
        two_words: vec![],
        three_words: vec![],
    };

    while iter_of_names.peek().is_some() {
        let next_item = iter_of_names.next().unwrap(); // kita bisa menggunakan .unwrap() karena kita tahu bahwa ia adalah Some
        match next_item.match_indices(' ').collect::&lt;Vec&lt;_&gt;&gt;().len() { // Buat sebuah vec menggunakan .match_indices dan periksa panjangnya
            0 =&gt; all_names.one_word.push(next_item.to_string()),
            1 =&gt; all_names.two_words.push(next_item.to_string()),
            _ =&gt; all_names.three_words.push(next_item.to_string()),
        }
    }

    println!(&quot;{:?}&quot;, all_names);
}
</code></pre></pre>
<p>Ia akan mencetak:</p>
<pre><code class="language-text">Names { one_word: [&quot;Caesar&quot;, &quot;Data&quot;], two_words: [&quot;Frodo Baggins&quot;, &quot;Bilbo Baggins&quot;, &quot;Jean-Luc Picard&quot;, &quot;Rand Al\'Thor&quot;, &quot;Paul Atreides&quot;], three_words:
[&quot;Barack Hussein Obama&quot;, &quot;Bill Jefferson Clinton&quot;] }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="Chapter_37.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="Chapter_39.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="Chapter_37.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="Chapter_39.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
