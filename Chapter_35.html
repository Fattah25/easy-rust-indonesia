<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> Traits - Easy Rust</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong> Updates</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong> Who am I?</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong> Catatan dari translator</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong> Writing Rust in Easy English</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong> Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong> üöß and ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong> Comments</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong> Types</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong> Type inference</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong> Printing 'hello, world!'</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong> Display and debug</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong> Mutability (changing)</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong> The stack, the heap, and pointers</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong> More about printing</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong> Strings</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong> const and static</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong> More on references</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong> Mutable references</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong> Giving references to functions</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong> Copy types</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong> Collection types</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong> Control flow</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong> Structs</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong> Enums</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong> Loops</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong> Implementing structs and enums</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong> Destructuring</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong> References and the dot operator</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong> Generics</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong> Option and Result</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong> Other collections</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong> The ? operator</a></li><li class="chapter-item expanded "><a href="Chapter_35.html" class="active"><strong aria-hidden="true">36.</strong> Traits</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong> Chaining methods</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong> Closures</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong> The dbg! macro and .inspect</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong> Types of &amp;str</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong> Cow</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong> The todo! macro</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong> Rc</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong> Multiple threads</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong> Closures in functions</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong> Arc</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong> Channels</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong> Reading Rust documentation</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong> Box</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong> Box around traits</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong> Default and the builder pattern</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong> Deref and DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong> Crates and modules</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong> Testing</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong> External crates</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong> A tour of the standard library</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong> Writing macros</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong> cargo</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong> Taking user input</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong> Using files</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="Chapter_67.html"><strong aria-hidden="true">68.</strong> The end?</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Easy Rust</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>Sebelumnya kita telah melihat beberapa trait: <code>Debug</code>, <code>Copy</code>, <code>Clone</code> semuanya adalah trait. Untuk memberikan trait ke sebuah type, Anda perlu mengimplementasiaknnya. Karena <code>Debug</code> dan yang lainnya sangatlah umum, kita memiliki attribute yang secara otomatis akan melakukannya. Itulah yang terjadi di saat Anda menuliskan <code>#[derive(Debug)]</code>: secara otomatis Anda mengimplementasikan <code>Debug</code>.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct MyStruct {
    number: usize,
}

fn main() {}
</code></pre></pre>
<p>Tapi traits yang lainnya lebih sulit lagi, karena Anda perlu mengimplementasikannya secara manual menggunakan <code>impl</code>. Contohnya, <code>Add</code> (berada pada <code>std::ops::Add</code>) digunakan untuk menambahkan 2 hal. Tapi Rust tidak tahu persis bagaimana Anda ingin menambahkan sesuatu, jadi Anda harus memberitahukannya kepada compiler.</p>
<pre><pre class="playground"><code class="language-rust">struct ThingsToAdd {
    first_thing: u32,
    second_thing: f32,
}

fn main() {}
</code></pre></pre>
<p>Kita bisa menambahkan <code>first_thing</code> dan <code>second_thing</code>, namun kita perlu untuk memberikan informasi lebih lanjut. Mungkin kita ingin hasilnya adalah <code>f32</code>, sehingga ditulis seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let result = self.second_thing + self.first_thing as f32
<span class="boring">}
</span></code></pre></pre>
<p>Atau mungkin kita menginginkan integer sebagai hasilnya, maka seperti inilah codenya:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let result = self.second_thing as u32 + self.first_thing
<span class="boring">}
</span></code></pre></pre>
<p>Atau mungkin kita ingin sekedar meletakkan <code>self.first_thing</code> disebelah <code>self.second_thing</code> dan mengatakan pada compiler bahwa ini adalah cara kita ingin melakukan penambahannya. Sehingga jika kita menambahkan 55 dan 33.4, kita ingin hasil akhirnya adalah 5533.4, bukan 88.4.</p>
<p>Jadi, pertama, kita lihat terlebih dahulu bagaimana cara membuat trait. Yang terpenting untuk diingat dari <code>trait</code> adalah bahwa ia menyangkut tentang behaviour/sifat/watak. Untuk membuat trait, tuliskan <code>trait</code> dan kemudian buatkan functionnya.</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // struct sederhana - Animal yang hanya memiliki nama
    name: String,
}

trait Dog { // Dog trait memberikan beberapa functionality/kegunaan
    fn bark(&amp;self) { // Ia bisa menggonggong
        println!(&quot;Woof woof!&quot;);
    }
    fn run(&amp;self) { // dan Ia bisa berlari
        println!(&quot;The dog is running!&quot;);
    }
}

impl Dog for Animal {} // Sekarang, Animal memiliki trait/sifat/watak dari Dog

fn main() {
    let rover = Animal {
        name: &quot;Rover&quot;.to_string(),
    };

    rover.bark(); // Sekarang Animal bisa menggunakan bark()
    rover.run();  // dan juga bisa menggunakan run()
}
</code></pre></pre>
<p>Programnya berjalan, namun kita tidak ingin mencetak &quot;The dog is running&quot;. Anda bisa mengubah method yang diberikan <code>trait</code> jika Anda menginginkannya, tapi Anda harus memiliki type yang sama. Itu berarti ia perlu mengambil hal yang sama, dan mengembalikan hal yang sama pula. Contohnya, kita bisa mengubah method <code>.run()</code>, namun kita harus mengikuti signaturenya. Berikut signaturenya:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
fn run(&amp;self) {
    println!(&quot;The dog is running!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>fn run(&amp;self)</code> berarti &quot;fn <code>run()</code> mengambil <code>&amp;self</code>, dan tidak me-return apapun&quot;. Sehingga Anda tidak bisa melakukan hal seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run(&amp;self) -&gt; i32 { // ‚ö†Ô∏è
    5
}
<span class="boring">}
</span></code></pre></pre>
<p>Compiler Rust akan mengatakan:</p>
<pre><code class="language-text">   = note: expected fn pointer `fn(&amp;Animal)`
              found fn pointer `fn(&amp;Animal) -&gt; i32`
</code></pre>
<p>Tapi kita bisa melakukan hal seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">struct Animal { // struct sederhana - Animal yang hanya memiliki nama
    name: String,
}

trait Dog { // Dog trait memberikan beberapa functionality/kegunaan
    fn bark(&amp;self) { // Ia bisa menggonggong
        println!(&quot;Woof woof!&quot;);
    }
    fn run(&amp;self) { // dan Ia bisa berlari
        println!(&quot;The dog is running!&quot;);
    }
}

impl Dog for Animal {
    fn run(&amp;self) {
        println!(&quot;{} is running!&quot;, self.name);
    }
}

fn main() {
    let rover = Animal {
        name: &quot;Rover&quot;.to_string(),
    };

    rover.bark(); // Sekarang Animal bisa menggunakan bark()
    rover.run();  // dan juga bisa menggunakan run()
}
</code></pre></pre>
<p>Sekarang ia akan mencetak <code>Rover is running!</code>. Programnya berjalan karena kita me-return <code>()</code> (tidak ada apapun), yang mana itu adalah signature traitnya.</p>
<p>Saat Anda membuat sebuah trait, Anda bisa menuliskan hanya function signaturenya saja (tanpa ada instruksi apapun). Namun jika Anda melakukan hal itu, user (programmer lainnya) yang nantinya menggunakannya haruslah menuliskan functionnya. Mari kita coba. Sekarang kita ubah <code>bark()</code> dan <code>run()</code> hanya dengan menuliskannya dengan <code>fn bark(&amp;self);</code> dan <code>fn run(&amp;self);</code>. Ini bukanlah function yang utuh (hanya sekedar signature), sehingga user yang ingin menggunakannya harus menuliskan function utuhnya di <code>impl</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct Animal {
    name: String,
}

trait Dog {
    fn bark(&amp;self); // bark() mengatakan bahwa ia memerlukan &amp;self dan tidak me-return apapun
    fn run(&amp;self); // run() mengatakan bahwa ia memerlukan &amp;self dan tidak me-return apapun.
                   // Sehingga sekarang kita harus menuliskan fungsinya sendiri.
}

impl Dog for Animal {
    fn bark(&amp;self) {
        println!(&quot;{}, stop barking!!&quot;, self.name);
    }
    fn run(&amp;self) {
        println!(&quot;{} is running!&quot;, self.name);
    }
}

fn main() {
    let rover = Animal {
        name: &quot;Rover&quot;.to_string(),
    };

    rover.bark();
    rover.run();
}
</code></pre></pre>
<p>Jadi saat Anda membuat sebuah trait, Anda harus memikirkan: &quot;Function yang mana yang harus Aku tulis? Dan function yang mana yang harus ditulis sendiri oleh user?&quot; Jika Anda berfikir bahwa user akan menggunakan function yang sama setiap saat, maka tuliskan saja functionnya. Jika Anda berfikir bahwa user akan menggunakannya secara berbeda, maka cukup tuliskan function signaturenya saja.</p>
<p>Jadi, mari kita coba implementasikan trait Display pada struct yang kita buat ini. Pertama-tama, kita akan membuat struct yang sederhana:</p>
<pre><pre class="playground"><code class="language-rust">struct Cat {
    name: String,
    age: u8,
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };
}
</code></pre></pre>
<p>Sekarang kita ingin mencetak <code>mr_mantle</code>. Debug sangat mudah diimplementasikan menggunakan derive:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Cat {
    name: String,
    age: u8,
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };

    println!(&quot;Mr. Mantle is a {:?}&quot;, mr_mantle);
}
</code></pre></pre>
<p>namun Debug print bukanlah cara &quot;tercantik&quot; untuk melakukan print, karena ia akan terlihat seperti ini.</p>
<pre><code class="language-text">Mr. Mantle is a Cat { name: &quot;Reggie Mantle&quot;, age: 4 }
</code></pre>
<p>Sehingga kita perlu untuk mengimplementasikan <code>Display</code> pada <code>Cat</code> jika kita ingin hasil cetaknya terlihat lebih baik. Pada <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">https://doc.rust-lang.org/std/fmt/trait.Display.html</a> kita bisa melihat informasi tentang Display, dan juga satu contoh yang telah disediakan. Contohnya mirip seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Position {
    longitude: f32,
    latitude: f32,
}

impl fmt::Display for Position {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.longitude, self.latitude)
    }
}

fn main() {}
</code></pre></pre>
<p>Pada code di atas, ada beberapa bagian yang belum bisa kita pahami, seperti <code>&lt;'_&gt;</code> dan apa yang <code>f</code> lakukan. Tapi kita paham tentang struct <code>Position</code>: struct yang berisi dua buah field yang keduanya bertype <code>f32</code>. Kita juga mengerti bahwa <code>self.longitude</code> dan <code>self.latitude</code> adalah field dari struct. Jadi mungkin kita bisa menggunakan code ini untuk struct yang kita buat, yaitu dengan <code>self.name</code> dan <code>self.age</code>. Juga, <code>write!</code> terlihat mirip dengan <code>println!</code> sehingga kita cukup familiar. Sehingga kita bisa menuliskannya seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} is a cat who is {} years old.&quot;, self.name, self.age)
    }
}

fn main() {}
</code></pre></pre>
<p>Mari kita tambahkan <code>fn main()</code>. Sekarang code kita terlihat seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
      write!(f, &quot;{} is a cat who is {} years old.&quot;, self.name, self.age)
  }
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };

    println!(&quot;{}&quot;, mr_mantle);
}
</code></pre></pre>
<p>Voila! Berhasil. Sekarang saat kita menggunakan <code>{}</code> untuk melakuka print, kita mendapatkan <code>Reggie Mantle is a cat who is 4 years old.</code>. Ini terlihat lebih baik.</p>
<p>Ah ya, jika Anda mengimplementasikan <code>Display</code> maka Anda secara otomatis mendapatkan trait <code>ToString</code>. Itu terjadi karena Anda menggunakan macro <code>format!</code> untuk function <code>.fmt()</code>, yang memungkinkan Anda membuat <code>String</code> dengan <code>.to_string()</code>. Jadi kita bisa melakukan hal seperti ini dimana kita melakukan pass pada <code>mr_mantle</code> ke function yang memerlukan <code>String</code>, atau yang lainnya.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
struct Cat {
    name: String,
    age: u8,
}

impl fmt::Display for Cat {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{} is a cat who is {} years old.&quot;, self.name, self.age)
    }
}

fn print_cats(pet: String) {
    println!(&quot;{}&quot;, pet);
}

fn main() {
    let mr_mantle = Cat {
        name: &quot;Reggie Mantle&quot;.to_string(),
        age: 4,
    };

    print_cats(mr_mantle.to_string()); // ubah mr_mantle yang semula adalah Cat menjadi String
    println!(&quot;Mr. Mantle's String is {} letters long.&quot;, mr_mantle.to_string().chars().count()); // ubah ia menjadi char dan hitung total charnya
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">Reggie Mantle is a cat who is 4 years old.
Mr. Mantle's String is 42 letters long.
</code></pre>
<p>Hal yang perlu diingat tentang trait adalah bahwa trait itu adalah behaviour/sifat dari sesuatu. Bagaimana <code>struct</code> Anda bertindak? Tindakan apa saja yang bisa dilakukannya? Untuk itulah trait ada. Jika Anda memikirkan tentang beberapa trait yang telah kita lihat sejauh ini, semuanya adalah tentang perilaku/sifat/watak: <code>Copy</code> adalah sesuatu yang bisa dilakukan oleh sebuah type. <code>Display</code> juga adalah sesuatu yang bisa dilakukan oleh sebuah type. <code>ToString</code> adalah trait lainnya, dan ia juga adalah sesuatu yang bisa dilakukan oleh sebuah type: ia bisa mengubah sesuatu menjadi <code>String</code>. Pada trait <code>Dog</code>, kata <em>dog</em> bukan berarti adalah sesuatu yang Anda lakukan, tapi lebih tepatnya adalah memberikannya satu atau beberapa method yang memungkinkannya untuk melakukan sesuatu. Anda juga bisa mengimplementasikannya pada <code>struct Poodle</code> atau <code>struct Beagle</code> dan mereka semua diberikan method yang berada di trait <code>Dog</code>.</p>
<p>Mari kita melihat pada contoh lain yang lebih berhubungan tentang perilaku. Kita akan membayangkan sebuah game fantasi dengan beberapa karakter sederhana. Salah satu karakternya adalah <code>Monster</code>, dan yang lainnya adalah <code>Wizard</code> dan <code>Ranger</code>. <code>Monster</code> hanya memiliki <code>health</code> sehingga kita bisa menyerangnya. Sementara dua karakter lainnya belum kita berikan apapun. Tapi kita buat dua buah trait. Yang satu bernama <code>FightClose</code>, yang memungkinkan Anda bertarung dari jarak dekat. Trait yang lainnya adalah <code>FightFromDistance</code>, yang membuat Anda bisa bertarung jarak jauh. Hanya <code>Ranger</code> yang bisa menggunakan <code>FightFromDistance</code>. Berikut adalah codenya:</p>
<pre><pre class="playground"><code class="language-rust">struct Monster {
    health: i32,
}

struct Wizard {}
struct Ranger {}

trait FightClose {
    fn attack_with_sword(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 10;
        println!(
            &quot;You attack with your sword. Your opponent now has {} health left.&quot;,
            opponent.health
        );
    }
    fn attack_with_hand(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 2;
        println!(
            &quot;You attack with your hand. Your opponent now has {} health left.&quot;,
            opponent.health
        );
    }
}
impl FightClose for Wizard {}
impl FightClose for Ranger {}

trait FightFromDistance {
    fn attack_with_bow(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 10 {
            opponent.health -= 10;
            println!(
                &quot;You attack with your bow. Your opponent now has {} health left.&quot;,
                opponent.health
            );
        }
    }
    fn attack_with_rock(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 3 {
            opponent.health -= 4;
        }
        println!(
            &quot;You attack with your rock. Your opponent now has {} health left.&quot;,
            opponent.health
        );
    }
}
impl FightFromDistance for Ranger {}

fn main() {
    let radagast = Wizard {};
    let aragorn = Ranger {};

    let mut uruk_hai = Monster { health: 40 };

    radagast.attack_with_sword(&amp;mut uruk_hai);
    aragorn.attack_with_bow(&amp;mut uruk_hai, 8);
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left.
You attack with your bow. Your opponent now has 20 health left.
</code></pre>
<p>Kita pass <code>self</code> di dalam trait yang kita buat setiap saat, tapi kita tidak bisa melakukan banyak hal dengan <code>self</code> untuk sekarang ini. Itu karena Rust tidak tahu type apa yang akan menggunakannya. Bisa saja <code>Wizard</code> yang menggunakannya, bisa juga <code>Ranger</code>, atau mungkin juga struct baru yang kita beri nama dengan <code>Toefocfgetobjtnode</code> atau apapun itu. Untuk memberikan beberapa fungsionalitas kepada <code>self</code>, kita bisa menambahkan sifat-sifat lain yang diperlukan pada trait, atau dalam kata lain, kita bisa menambahkan trait ke trait lainnya. Jika kita ingin melakukan print menggunakan <code>{:?}</code> sebagai contoh, maka kita memerlukan <code>Debug</code>. Anda bisa menambahkannya ke trait hanya dengan menuliskannya setelah <code>:</code> (colon). Sekarang codenya terlihat seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">struct Monster {
    health: i32,
}

#[derive(Debug)] // Sekarang Wizard memiliki Debug
struct Wizard {
    health: i32, // Sekarang Wizard memiliki health
}
#[derive(Debug)] // Begitu juga dengan Ranger
struct Ranger {
    health: i32, // Begitu juga dengan Ranger
}

trait FightClose: std::fmt::Debug { // Sekarang type memerlukan Debug untuk menggunakan FightClose
    fn attack_with_sword(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 10;
        println!(
            &quot;You attack with your sword. Your opponent now has {} health left. You are now at: {:?}&quot;, // Kita sekarang bisa mencetak self menggunakan {:?} karena kita memiliki Debug
            opponent.health, &amp;self
        );
    }
    fn attack_with_hand(&amp;self, opponent: &amp;mut Monster) {
        opponent.health -= 2;
        println!(
            &quot;You attack with your hand. Your opponent now has {} health left.  You are now at: {:?}&quot;,
            opponent.health, &amp;self
        );
    }
}
impl FightClose for Wizard {}
impl FightClose for Ranger {}

trait FightFromDistance: std::fmt::Debug { // Kita juga bisa melakukan hal seperti ini pada trait, `FightFromDistance: FightClose` , karena FightClose sudah menggunakan Debug, tapi ini adalah hal yang berbeda karena dengan cara ini Ranger bisa mengakses trait Wizard.
    fn attack_with_bow(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 10 {
            opponent.health -= 10;
            println!(
                &quot;You attack with your bow. Your opponent now has {} health left.  You are now at: {:?}&quot;,
                opponent.health, self
            );
        }
    }
    fn attack_with_rock(&amp;self, opponent: &amp;mut Monster, distance: u32) {
        if distance &lt; 3 {
            opponent.health -= 4;
        }
        println!(
            &quot;You attack with your rock. Your opponent now has {} health left.  You are now at: {:?}&quot;,
            opponent.health, self
        );
    }
}
impl FightFromDistance for Ranger {}

fn main() {
    let radagast = Wizard { health: 60 };
    let aragorn = Ranger { health: 80 };

    let mut uruk_hai = Monster { health: 40 };

    radagast.attack_with_sword(&amp;mut uruk_hai);
    aragorn.attack_with_bow(&amp;mut uruk_hai, 8);
}
</code></pre></pre>
<p>Hasil printnya adalah sebagai berikut:</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left. You are now at: Wizard { health: 60 }
You attack with your bow. Your opponent now has 20 health left.  You are now at: Ranger { health: 80 }
</code></pre>
<p>Di dalam real game, akan lebih baik untuk menulis ulang ini untuk setiap typenya, karena <code>You are now at: Wizard { health: 60 }</code> terlihat agak aneh. Itu juga mengapa method di dalam trait biasanya ditulis dengan simple, karena kita tidak tahu type apa yang akan menggunakannya. Sebagai contoh, Anda tidak bisa menuliskan hal seperti <code>self.0 += 10</code>. Tapi contoh ini menujukkan bahwa kita bisa menggunkan trait lain di dalam trait yang kita buat. Dan di saat kita melakukan hal itu, kita mendapatkan beberapa methods yang bisa kita gunakan.</p>
<p>Satu cara lain untuk menggunakan trait adalah dengan cara yang biasa disebut sebagai <code>trait bounds</code>. Yang artinya &quot;pembatasan oleh trait&quot;. Trait bounds sangatlah mudah karena trait sebenarnya tidak perlu dimasukkan method apapun, ataupun hal-hal lainnya. Mari kita tuliskan ulang code kita di atas dengan sesuatu yang serupa tapi berbeda. Untuk kali ini, trait kita tidak memiliki method apapun, tapi kita memiliki function lain yang memerlukan trait untuk menggunakannya.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;  // Kita tidak perlu menuliskan std::fmt::Debug setiap saat

struct Monster {
    health: i32,
}

#[derive(Debug)]
struct Wizard {
    health: i32,
}
#[derive(Debug)]
struct Ranger {
    health: i32,
}

trait Magic{} // Tidak ada method yang dituliskan didalam trait-trait ini. Mereka hanyalah trait bounds
trait FightClose {}
trait FightFromDistance {}

impl FightClose for Ranger{} // Setiap type mendapatkan FightClose,
impl FightClose for Wizard {}
impl FightFromDistance for Ranger{} // tapi hanya Ranger yang mendapatkan FightFromDistance
impl Magic for Wizard{}  // dan hanya Wizard yang mendapatkan Magic

fn attack_with_bow&lt;T: FightFromDistance + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster, distance: u32) {
    if distance &lt; 10 {
        opponent.health -= 10;
        println!(
            &quot;You attack with your bow. Your opponent now has {} health left.  You are now at: {:?}&quot;,
            opponent.health, character
        );
    }
}

fn attack_with_sword&lt;T: FightClose + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster) {
    opponent.health -= 10;
    println!(
        &quot;You attack with your sword. Your opponent now has {} health left. You are now at: {:?}&quot;,
        opponent.health, character
    );
}

fn fireball&lt;T: Magic + Debug&gt;(character: &amp;T, opponent: &amp;mut Monster, distance: u32) {
    if distance &lt; 15 {
        opponent.health -= 20;
        println!(&quot;You raise your hands and cast a fireball! Your opponent now has {} health left. You are now at: {:?}&quot;,
    opponent.health, character);
    }
}

fn main() {
    let radagast = Wizard { health: 60 };
    let aragorn = Ranger { health: 80 };

    let mut uruk_hai = Monster { health: 40 };

    attack_with_sword(&amp;radagast, &amp;mut uruk_hai);
    attack_with_bow(&amp;aragorn, &amp;mut uruk_hai, 8);
    fireball(&amp;radagast, &amp;mut uruk_hai, 8);
}
</code></pre></pre>
<p>Hasil print dari program tersebut adalah seperti berikut:</p>
<pre><code class="language-text">You attack with your sword. Your opponent now has 30 health left. You are now at: Wizard { health: 60 }
You attack with your bow. Your opponent now has 20 health left.  You are now at: Ranger { health: 80 }
You raise your hands and cast a fireball! Your opponent now has 0 health left. You are now at: Wizard { health: 60 }
</code></pre>
<p>Jadinya Anda bisa melihat ada banyak cara untuk melakukan hal yang sama di saat Anda menggunakan trait. Itu semua tergantung pada apa yang paling masuk akal untuk program yang sedang Anda tulis.</p>
<p>Sekarang mari kita lihat bagaimana mengimplementasikan beberapa trait utama yang akan Anda gunakan di Rust.</p>
<h3 id="the-from-trait"><a class="header" href="#the-from-trait">The From trait</a></h3>
<p><em>From</em> adalah trait yang mudah untuk digunakan, dan Anda mengetahui ini karena Anda sudah sering melihatnya. Dengan <em>From</em> Anda tidak hanya bisa membuat <code>String</code> dari <code>&amp;str</code>, bahkan Anda dapat membuat banyak type dari berbagai type lainnya. Sebagai contoh, Vec menggunakan <em>From</em> untuk hal-hal berikut ini:</p>
<pre><code class="language-text">From&lt;&amp;'_ [T]&gt;
From&lt;&amp;'_ mut [T]&gt;
From&lt;&amp;'_ str&gt;
From&lt;&amp;'a Vec&lt;T&gt;&gt;
From&lt;[T; N]&gt;
From&lt;BinaryHeap&lt;T&gt;&gt;
From&lt;Box&lt;[T]&gt;&gt;
From&lt;CString&gt;
From&lt;Cow&lt;'a, [T]&gt;&gt;
From&lt;String&gt;
From&lt;Vec&lt;NonZeroU8&gt;&gt;
From&lt;Vec&lt;T&gt;&gt;
From&lt;VecDeque&lt;T&gt;&gt;
</code></pre>
<p>Banyak sekali <code>Vec::from()</code> yang belum kita coba. Mari kita buat beberapa dan lihat apa yang terjadi.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display; // Kita akan membuat generic function untuk mencetaknya, sehingga kita memerlukan Display

fn print_vec&lt;T: Display&gt;(input: &amp;Vec&lt;T&gt;) { // Ambil Vec&lt;T&gt; jika type T memiliki Display
    for item in input {
        print!(&quot;{} &quot;, item);
    }
    println!();
}

fn main() {

    let array_vec = Vec::from([8, 9, 10]); // mencoba menggunakannya pada array
    print_vec(&amp;array_vec);

    let str_vec = Vec::from(&quot;What kind of vec will I be?&quot;); // array dari sebuah &amp;str? Ini cukup menarik
    print_vec(&amp;str_vec);

    let string_vec = Vec::from(&quot;What kind of vec will a String be?&quot;.to_string()); // juga dari String
    print_vec(&amp;string_vec);
}
</code></pre></pre>
<p>Hasilnya adalah sebagai berikut:</p>
<pre><code class="language-text">8 9 10
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 73 32 98 101 63
87 104 97 116 32 107 105 110 100 32 111 102 32 118 101 99 32 119 105 108 108 32 97 32 83 116 114 105 110 103 32 98 101 63
</code></pre>
<p>Jika Anda melihat typenya, vector yang kedua dan ketiga adalah <code>Vec&lt;u8&gt;</code>, yang mana artinya ia berisi byte dari <code>&amp;str</code> dan <code>String</code>. Jadi Anda bisa melihat bahwa <code>From</code> sangatlah fleksibel dan sering digunakan. Mari kita coba dengan type yang kita buat sendiri.</p>
<p>Kita akan membuat dua struct dan kemudian mengimplementasikan <code>From</code> ke salah satu dari struct tersebut. Satu struct akan kita beri nama <code>City</code>, dan yang satu lagi akan kita beri nama <code>Country</code>. Kita ingin bisa melakukan hal seperti ini: <code>let country_name = Country::from(vector_of_cities)</code>.</p>
<p>Codenya seperti berikut:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // agar kita bisa melakukan debug print untuk City
struct City {
    name: String,
    population: u32,
}

impl City {
    fn new(name: &amp;str, population: u32) -&gt; Self { // hanya new function
        Self {
            name: name.to_string(),
            population,
        }
    }
}
#[derive(Debug)] // Country juga perlu untuk diprint
struct Country {
    cities: Vec&lt;City&gt;, // vektor yang berisi nama-nama kota dimasukkan ke sini
}

impl From&lt;Vec&lt;City&gt;&gt; for Country { // Catatan: kita tidak harus menulis From&lt;City&gt;, kita juga bisa menulis
                                   // From&lt;Vec&lt;City&gt;&gt;. Sehingga kita juga bisa mengimplementasikannya pada type
                                   // yang tidak kita buat
    fn from(cities: Vec&lt;City&gt;) -&gt; Self {
        Self { cities }
    }
}

impl Country {
    fn print_cities(&amp;self) { // function untuk melakukan print kota-kota yang ada di dalam Country
        for city in &amp;self.cities {
            // &amp; karena Vec&lt;City&gt; bukanlah Copy
            println!(&quot;{:?} has a population of {:?}.&quot;, city.name, city.population);
        }
    }
}

fn main() {
    let helsinki = City::new(&quot;Helsinki&quot;, 631_695);
    let turku = City::new(&quot;Turku&quot;, 186_756);

    let finland_cities = vec![helsinki, turku]; // Ini adalah Vec&lt;City&gt;
    let finland = Country::from(finland_cities); // Sekarang kita bisa menggunakan From

    finland.print_cities();
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">&quot;Helsinki&quot; has a population of 631695.
&quot;Turku&quot; has a population of 186756.
</code></pre>
<p>Anda bisa melihat bahwa <code>From</code> sangatlah mudah untuk diimplementasikan dari type-type yang tidak kita buat seperti <code>Vec</code>, <code>i32</code>, dan seterusnya. Ini ada satu contoh lagi dimana kita membuat sebuah vector yang di dalamnya memiliki 2 vector. Vector yang pertama berisi angka-angka genap, dan vector yang kedua berisi angka-angka ganjil. Dengan <code>From</code> Anda bisa memberikannya vector bertype <code>i32</code> dan ia akan mengembalikannya dalam bentuk <code>Vec&lt;Vec&lt;i32&gt;&gt;</code>: vector yang berisi vector bertype <code>i32</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::From;

struct EvenOddVec(Vec&lt;Vec&lt;i32&gt;&gt;);

impl From&lt;Vec&lt;i32&gt;&gt; for EvenOddVec {
    fn from(input: Vec&lt;i32&gt;) -&gt; Self {
        let mut even_odd_vec: Vec&lt;Vec&lt;i32&gt;&gt; = vec![vec![], vec![]]; // Vec dengan dua vec kosong didalamnya
                                                                    // Ini adalah value kembalian, tapi pertama-tama kita harus mengisinya
        for item in input {
            if item % 2 == 0 {
                even_odd_vec[0].push(item);
            } else {
                even_odd_vec[1].push(item);
            }
        }
        Self(even_odd_vec) // Selesai, sehingga kita me-returnnya sebagai Self (Self = EvenOddVec)
    }
}

fn main() {
    let bunch_of_numbers = vec![8, 7, -1, 3, 222, 9787, -47, 77, 0, 55, 7, 8];
    let new_vec = EvenOddVec::from(bunch_of_numbers);

    println!(&quot;Even numbers: {:?}\nOdd numbers: {:?}&quot;, new_vec.0[0], new_vec.0[1]);
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">Even numbers: [8, 222, 0, 8]
Odd numbers: [7, -1, 3, 9787, -47, 77, 55, 7]
</code></pre>
<p>Type seperti <code>EvenOddVec</code> mungkin akan lebih baik apabila ditulis sebagai generic <code>T</code>, sehingga kita bia menggunakan banyak type angka. Anda bisa mencoba untuk membuat contoh dengan menggunakan generic jika Anda ingin mempelajarinya.</p>
<h3 id="taking-a-string-and-a-str-in-a-function"><a class="header" href="#taking-a-string-and-a-str-in-a-function">Taking a String and a &amp;str in a function</a></h3>
<p>Terkadang Anda menginginkan sebuah function yang bisa mengambil value dari <code>String</code> dan juga <code>&amp;str</code>. Anda bisa melakukan ini menggunakan generic dan menggunakan trait <code>AsRef</code>. <code>AsRef</code> digunakan untuk memberikan reference dari satu type ke type yang lainnya. Jika Anda lihat pada dokumentasi untuk <code>String</code>, Anda bisa melihat bahwa ia memiliki <code>AsRef</code> untuk berbagai macam type:</p>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html">https://doc.rust-lang.org/std/string/struct.String.html</a></p>
<p>Ini adalah beberapa function signaturenya.</p>
<p><code>AsRef&lt;str&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
impl AsRef&lt;str&gt; for String

fn as_ref(&amp;self) -&gt; &amp;str
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef&lt;[u8]&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
impl AsRef&lt;[u8]&gt; for String

fn as_ref(&amp;self) -&gt; &amp;[u8]
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef&lt;OsStr&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
impl AsRef&lt;OsStr&gt; for String

fn as_ref(&amp;self) -&gt; &amp;OsStr
<span class="boring">}
</span></code></pre></pre>
<p>Anda bisa melihat bahwa ia akan mengambil <code>&amp;self</code> sebagai parameter dan memberikan return berupa reference ke type yang lain. Ini artinya bahwa jika kita memiliki generic type T, kita bisa mengatakan bahwa ia memerlukan <code>AsRef&lt;str&gt;</code>. Jika Anda melakukan itu, maka ia bisa mengambil <code>&amp;str</code> dan <code>String</code>.</p>
<p>Kita mulai dengan generic function. Code dibawah ini tidak akan bekerja:</p>
<pre><pre class="playground"><code class="language-rust">fn print_it&lt;T&gt;(input: T) {
    println!(&quot;{}&quot;, input) // ‚ö†Ô∏è
}

fn main() {
    print_it(&quot;Please print me&quot;);
}
</code></pre></pre>
<p>Rust mengatakan <code>error[E0277]: T doesn't implement std::fmt::Display</code>. Jadi kita memerlukan T untuk diimplementasikan dengan Display.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_it&lt;T: Display&gt;(input: T) {
    println!(&quot;{}&quot;, input)
}

fn main() {
    print_it(&quot;Please print me&quot;);
}
</code></pre></pre>
<p>Sekarang codenya bekerja dan mencetak <code>Please print me</code>. Itu bagus, tapi tetap saja T itu bertype apapun. Bisa saja ia <code>i8</code>, <code>f32</code> dan type apapun yang memiliki <code>Display</code>. Sehingga kita menambahkan <code>AsRef&lt;str&gt;</code>, dan sekarang T memerlukan 2 trait, yaitu <code>AsRef&lt;str&gt;</code> dan <code>Display</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

fn print_it&lt;T: AsRef&lt;str&gt; + Display&gt;(input: T) {
    println!(&quot;{}&quot;, input)
}

fn main() {
    print_it(&quot;Please print me&quot;);
    print_it(&quot;Also, please print me&quot;.to_string());
    // print_it(7); &lt;- Ini tidak akan tercetak
}
</code></pre></pre>
<p>Sekarang ia tidak bisa mencetak type <code>i8</code>.
Jangan lupa bahwa Anda bisa menggunakan <code>where</code> untuk menulis function dengan cara yang berbeda di saat ia mulai panjang. Jika kita menambahkan Debug, maka ia menjadi <code>fn print_it&lt;T: AsRef&lt;str&gt; + Display + Debug&gt;(input: T)</code> yang mana ini terlalu panjan untuk ditulis dalam 1 baris. Jadi kita bisa menuliskannya seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::{Debug, Display}; // tambahkan Debug

fn print_it&lt;T&gt;(input: T) // Sekarang baris ini menjadi mudah untuk dibaca
where
    T: AsRef&lt;str&gt; + Debug + Display, // dan trait-trait ini pun menjadi mudah juga untuk dibaca
{
    println!(&quot;{}&quot;, input)
}

fn main() {
    print_it(&quot;Please print me&quot;);
    print_it(&quot;Also, please print me&quot;.to_string());
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="Chapter_34.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="Chapter_36.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="Chapter_34.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="Chapter_36.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
