<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> Default and the builder pattern - Easy Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong> Updates</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong> Who am I?</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong> Catatan dari translator</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong> Writing Rust in Easy English</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong> Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong> üöß and ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong> Comments</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong> Types</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong> Type inference</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong> Printing 'hello, world!'</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong> Display and debug</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong> Mutability (changing)</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong> The stack, the heap, and pointers</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong> More about printing</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong> Strings</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong> const and static</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong> More on references</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong> Mutable references</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong> Giving references to functions</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong> Copy types</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong> Collection types</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong> Control flow</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong> Structs</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong> Enums</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong> Loops</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong> Implementing structs and enums</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong> Destructuring</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong> References and the dot operator</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong> Generics</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong> Option and Result</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong> Other collections</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong> The ? operator</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong> Traits</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong> Chaining methods</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong> Closures</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong> The dbg! macro and .inspect</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong> Types of &amp;str</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong> Cow</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong> The todo! macro</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong> Rc</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong> Multiple threads</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong> Closures in functions</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong> Arc</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong> Channels</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong> Reading Rust documentation</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong> Box</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong> Box around traits</a></li><li class="chapter-item expanded "><a href="Chapter_56.html" class="active"><strong aria-hidden="true">57.</strong> Default and the builder pattern</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong> Deref and DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong> Crates and modules</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong> Testing</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong> External crates</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong> A tour of the standard library</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong> Writing macros</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong> cargo</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong> Taking user input</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong> Using files</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="Chapter_67.html"><strong aria-hidden="true">68.</strong> The end?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Easy Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="default-and-the-builder-pattern"><a class="header" href="#default-and-the-builder-pattern">Default and the builder pattern</a></h2>
<p>Anda bisa mengimplementasikan trait <code>Default</code> untuk memberi value ke <code>struct</code> atau <code>enum</code> yang menurut Anda paling umum (paling sering) digunakan. Builder pattern berfungsi dengan baik dengan menggunakan <code>Default</code> ini, agar pengguna dengan mudah membuat perubahan saat mereka mau. Pertama-tama, kita lihat terlebih dahulu apa itu <code>Default</code>. Sebenarnya, hampir semua type di Rust telah memiliki <code>Default</code>. Contohnya: 0, &quot;&quot; (empty strings), <code>false</code>, dll.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let default_i8: i8 = Default::default();
    let default_str: String = Default::default();
    let default_bool: bool = Default::default();

    println!(&quot;'{}', '{}', '{}'&quot;, default_i8, default_str, default_bool);
}
</code></pre></pre>
<p>Hasil printnya adalah <code>'0', '', 'false'</code>.</p>
<p>Jadinya, <code>Default</code> mirip seperti function <code>new</code>, namun Anda tidak memberikan input apapun. Pertama, kita akan membuat sebuah <code>struct</code> yang belum mengimplementasikan <code>Default</code>. Ia memiliki function <code>new</code> yang mana kita gunakan untuk membuat karakter bernama Billy dengan beberapa status.</p>
<pre><pre class="playground"><code class="language-rust">struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain
}

impl Character {
    fn new(name: String, age: u8, height: u32, weight: u32, alive: bool) -&gt; Self {
        Self {
            name,
            age,
            height,
            weight,
            lifestate: if alive { LifeState::Alive } else { LifeState::Dead },
        }
    }
}

fn main() {
    let character_1 = Character::new(&quot;Billy&quot;.to_string(), 15, 170, 70, true);
}
</code></pre></pre>
<p>Tapi, mungkin di dunia yang kita ciptakan ini kita menginginkan hampir semua karakternya bernama Billy, berusia 15, tinggi 170, berat 70, dan berstatus alive. Kita bisa mengimplementasikan <code>Default</code> sehingga kita bisa menuliskan <code>Character::default()</code>. Codenya terlihat seperti berikut:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new(name: String, age: u8, height: u32, weight: u32, alive: bool) -&gt; Self {
        Self {
            name,
            age,
            height,
            weight,
            lifestate: if alive {
                LifeState::Alive
            } else {
                LifeState::Dead
            },
        }
    }
}

impl Default for Character {
    fn default() -&gt; Self {
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }
}

fn main() {
    let character_1 = Character::default();

    println!(
        &quot;The character {:?} is {:?} years old.&quot;,
        character_1.name, character_1.age
    );
}
</code></pre></pre>
<p>Hasil printnya adalah <code>The character &quot;Billy&quot; is 15 years old.</code> Jauh lebih mudah!</p>
<p>Sekarang kita bahas builder pattern. Nantinya, kita akan memiliki banyak Billy, jadinya kita akan tetap menyimpan default valuenya. Tetapi banyak karakter lain yang hanya sedikit berbeda statnya. Builder pattern memungkinkan kita untuk melakukan chain menggunakan method-method sederhana untuk mengubah satu value. Ini adalah salah satu method yang dibuat untuk <code>Character</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn height(mut self, height: u32) -&gt; Self {    // üöß
    self.height = height;
    self
}
<span class="boring">}
</span></code></pre></pre>
<p>Perhatikan pula, bahwa untuk melakukan hal ini kita memerlukan <code>mut self</code>. Kita sudah melihatnya sekali sebelumnya, dan ini bukanlah mutable reference (<code>&amp;mut self</code>). Ia akan mengambil ownership dari <code>Self</code> dan dengan <code>mut</code> ia akan menjadi mutable, meskipun sebelumnya ia bukan mutable. Ini dikarenakan <code>.height()</code> memiliki full ownership (kepemilikan penuh) dan tidak ada siapapun yang bisa menyentuhnya, sehingga ia safe untuk menjadi mutable. Kemudian, ia hanya mengubah <code>self.height</code> dan mengembalikan <code>Self</code> (yang mana adalah <code>Character</code>).</p>
<p>Jadi, mari kita buat 3 buah builder method untuk Character. Ketiganya kurang lebih mirip satu sama lainnya:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn height(mut self, height: u32) -&gt; Self {     // üöß
    self.height = height;
    self
}

fn weight(mut self, weight: u32) -&gt; Self {
    self.weight = weight;
    self
}

fn name(mut self, name: &amp;str) -&gt; Self {
    self.name = name.to_string();
    self
}
<span class="boring">}
</span></code></pre></pre>
<p>Setiap satu method tersebut mengubah satu variabel dan mengembalikan <code>Self</code>: inilah apa yang kita lihat pada builder pattern. Jadi sekarang kita bisa menulis seperti ini untuk membuat karakter : <code>let character_1 = Character::default().height(180).weight(60).name(&quot;Bobby&quot;);</code>. Jika Anda sedang membuat library untuk digunakan oleh orang lain, ini akan memudahkan mereka. Ini sangatlah mudah untuk dipahami oleh pengguna lainnya, karena codenya bisa dipahami persis seperti kalimat berikut : &quot;Berikan aku karakter default, tetapi dengan tinggi 180, berat 60, dan namanya adalah Bobby .&quot; Sejauh ini, codenya akan menjadi seperti berikut:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new(name: String, age: u8, height: u32, weight: u32, alive: bool) -&gt; Self {
        Self {
            name,
            age,
            height,
            weight,
            lifestate: if alive {
                LifeState::Alive
            } else {
                LifeState::Dead
            },
        }
    }

    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self
    }

    fn weight(mut self, weight: u32) -&gt; Self {
        self.weight = weight;
        self
    }

    fn name(mut self, name: &amp;str) -&gt; Self {
        self.name = name.to_string();
        self
    }
}

impl Default for Character {
    fn default() -&gt; Self {
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }
}

fn main() {
    let character_1 = Character::default().height(180).weight(60).name(&quot;Bobby&quot;);

    println!(&quot;{:?}&quot;, character_1);
}
</code></pre></pre>
<p>Method terakhir yang ditambahkan biasanya disebut <code>.build()</code>. Method ini adalah semacam final check / pemeriksaan terakhir. Di saat Anda memberikan user sebuah method seperti <code>.height()</code>, Anda bisa memastikan bahwa mereka hanya memasukkan data yang bertype <code>u32()</code>, tapi bagaimana jika mereka memasukkan 5000 untuk tinggi karakternya? Tentu saja itu bukanlah hal yang baik untuk game yang Anda buat. Kita akan menggunakan method terakhir bernama <code>.build()</code> yang mengembalikan <code>Result</code>. Di dalam method tersebut, kita akan memeriksa apakah inputan dari user sudah benar, dan jika memang sudah benar, maka kita akan mengembalikan <code>Ok(Self)</code>.</p>
<p>Pertama, kita ubah terlebih dahulu method <code>.new()</code>. Kita tidak ingin user bebas membuat karakter apapun. Jadi kita akan memindahkan value dari <code>impl Default</code> ke <code>.new()</code>. Dan sekarang <code>.new()</code> tidak lagi mengambil inputan apapun.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new() -&gt; Self {    // üöß
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Ini berarti kita tidak lagi memerlukan <code>impl Default</code>, karena <code>.new()</code> telah memiliki semua default value. Jadinya kita bisa menghapus <code>impl Default</code>.</p>
<p>Sekarang codenya menjadi seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new() -&gt; Self {
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
        }
    }

    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self
    }

    fn weight(mut self, weight: u32) -&gt; Self {
        self.weight = weight;
        self
    }

    fn name(mut self, name: &amp;str) -&gt; Self {
        self.name = name.to_string();
        self
    }
}

fn main() {
    let character_1 = Character::new().height(180).weight(60).name(&quot;Bobby&quot;);

    println!(&quot;{:?}&quot;, character_1);
}
</code></pre></pre>
<p>Tentunya hasilnya pun akan sama: <code>Character { name: &quot;Bobby&quot;, age: 15, height: 180, weight: 60, lifestate: Alive }</code>.</p>
<p>Kita hampir siap untuk membuat method <code>.build()</code>, tapi masih ada satu problem: bagaimana caranya kita mendorong user untuk menggunakan method tersebut? Sekarang user bisa menuliskan <code>let x = Character::new().height(76767);</code> dan mendapatkan <code>Character</code>. Ada banyak cara untuk membuat (memaksa) user nantinya menggunakan method tersebut, dan mungkin Anda bisa membayangkan cara Anda sendiri. Tapi, disini kita akan menggunakan suatu cara, yaitu menambahkan value <code>can_use: bool</code> ke <code>Character</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]       // üöß
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
    can_use: bool, // field ini digunakan untuk menyetel apakah user bisa menggunakan karakter tersebut atau tidak
}

\\ Cut other code

    fn new() -&gt; Self {
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
            can_use: true, // .new() selalu mengembalikan Character, jadi secara default valuenya kita set ke true
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Dan untuk method lainnya seperti <code>.height()</code>, kita akan setel <code>can_use</code> menjadi <code>false</code>. Hanya method <code>.build()</code> yang akan mengubah <code>can_use</code> kembali menjadi <code>true</code>, so now the user has to do a final check with <code>.build()</code>. We will make sure that <code>height</code> is not above 200 and <code>weight</code> is not above 300. Also, in our game there is a bad word called <code>smurf</code> that we don't want characters to use.</p>
<p>Beginilah method <code>.build()</code> yang kita buat:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn build(mut self) -&gt; Result&lt;Character, String&gt; {      // üöß
    if self.height &lt; 200 &amp;&amp; self.weight &lt; 300 &amp;&amp; !self.name.to_lowercase().contains(&quot;smurf&quot;) {
        self.can_use = true;
        Ok(self)
    } else {
        Err(&quot;Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)&quot;
            .to_string())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>!self.name.to_lowercase().contains(&quot;smurf&quot;)</code> memastikan user tidak menuliskan sesuatu seperti &quot;SMURF&quot; atau &quot;IamSmurf&quot; . Ia membuat seluruh <code>String</code> tersebut menjadi lowercase (huruf kecil), dan memeriksa isinya menggunakan method <code>.contains()</code> (alih-alih menggunakan <code>==</code>). Dan <code>!</code> pada bagian awal tersebut adalah &quot;not&quot;.</p>
<p>Jika semua inputannya sudah benar, maka kita set <code>can_use</code> menjadi <code>true</code>, dan berikan <code>Character</code> ke user dengan dibungkus di dalam <code>Ok</code>.</p>
<p>Sekarang code kita telah selesai. Kita akan membuat tiga karakter yang tidak bisa dibuat, dan satu karakter yang bisa dibuat. Maka, codenya sekarang menjadi seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Character {
    name: String,
    age: u8,
    height: u32,
    weight: u32,
    lifestate: LifeState,
    can_use: bool, // Ini adalah value yang baru
}

#[derive(Debug)]
enum LifeState {
    Alive,
    Dead,
    NeverAlive,
    Uncertain,
}

impl Character {
    fn new() -&gt; Self {
        Self {
            name: &quot;Billy&quot;.to_string(),
            age: 15,
            height: 170,
            weight: 70,
            lifestate: LifeState::Alive,
            can_use: true,  // .new() secara otomatis akan menciptakan character, sehingga kita set dengan true
        }
    }

    fn height(mut self, height: u32) -&gt; Self {
        self.height = height;
        self.can_use = false; // Karena data default diubah melalui method .height(), user tidak bisa menggunakan karakter tersebut
        self
    }

    fn weight(mut self, weight: u32) -&gt; Self {
        self.weight = weight;
        self.can_use = false;
        self
    }

    fn name(mut self, name: &amp;str) -&gt; Self {
        self.name = name.to_string();
        self.can_use = false;
        self
    }

    fn build(mut self) -&gt; Result&lt;Character, String&gt; {
        if self.height &lt; 200 &amp;&amp; self.weight &lt; 300 &amp;&amp; !self.name.to_lowercase().contains(&quot;smurf&quot;) {
            self.can_use = true;   // Jika semua inputan sudah sesuai, maka akan diubah kembali menjadi true
            Ok(self)               // dan mengembalikan Character
        } else {
            Err(&quot;Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)&quot;
                .to_string())
        }
    }
}

fn main() {
    let character_with_smurf = Character::new().name(&quot;Lol I am Smurf!!&quot;).build(); // Berisi kata &quot;smurf&quot; - not okay
    let character_too_tall = Character::new().height(400).build(); // Terlalu tinggi - not okay
    let character_too_heavy = Character::new().weight(500).build(); // Terlalu berat - not okay
    let okay_character = Character::new()
        .name(&quot;Billybrobby&quot;)
        .height(180)
        .weight(100)
        .build();   // Karakter yang ini bisa dibuat. Namanya bisa diterima, tinggi dan beratnya juga sesuai

    // Kembaliannya bukan Character, melainkan Result&lt;Character, String&gt;. Jadi kita masukkan karakter-karakter di atas ke dalam Vec sehingga kita bisa melihatnya:
    let character_vec = vec![character_with_smurf, character_too_tall, character_too_heavy, okay_character];

    for character in character_vec { // Sekarang kita akan mencetak karakternya jika Ok, dan mencetak error jika ia adalah Err
        match character {
            Ok(character_info) =&gt; println!(&quot;{:?}&quot;, character_info),
            Err(err_info) =&gt; println!(&quot;{}&quot;, err_info),
        }
        println!(); // Tambahkan jeda 1 baris
    }
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)

Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)

Could not create character. Characters must have:
1) Height below 200
2) Weight below 300
3) A name that is not Smurf (that is a bad word)

Character { name: &quot;Billybrobby&quot;, age: 15, height: 180, weight: 100, lifestate: Alive, can_use: true }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Chapter_55.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="Chapter_57.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Chapter_55.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="Chapter_57.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
