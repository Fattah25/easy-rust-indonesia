<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> Using files - Easy Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong> Updates</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong> Who am I?</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong> Catatan dari translator</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong> Writing Rust in Easy English</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong> Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong> üöß and ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong> Comments</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong> Types</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong> Type inference</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong> Printing 'hello, world!'</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong> Display and debug</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong> Mutability (changing)</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong> The stack, the heap, and pointers</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong> More about printing</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong> Strings</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong> const and static</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong> More on references</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong> Mutable references</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong> Giving references to functions</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong> Copy types</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong> Collection types</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong> Control flow</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong> Structs</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong> Enums</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong> Loops</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong> Implementing structs and enums</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong> Destructuring</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong> References and the dot operator</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong> Generics</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong> Option and Result</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong> Other collections</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong> The ? operator</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong> Traits</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong> Chaining methods</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong> Closures</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong> The dbg! macro and .inspect</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong> Types of &amp;str</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong> Cow</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong> The todo! macro</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong> Rc</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong> Multiple threads</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong> Closures in functions</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong> Arc</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong> Channels</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong> Reading Rust documentation</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong> Box</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong> Box around traits</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong> Default and the builder pattern</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong> Deref and DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong> Crates and modules</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong> Testing</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong> External crates</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong> A tour of the standard library</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong> Writing macros</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong> cargo</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong> Taking user input</a></li><li class="chapter-item expanded "><a href="Chapter_65.html" class="active"><strong aria-hidden="true">66.</strong> Using files</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="Chapter_67.html"><strong aria-hidden="true">68.</strong> The end?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Easy Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="using-files"><a class="header" href="#using-files">Using files</a></h2>
<p>Sekarang setelah kita menggunakan Rust di komputer, kita bisa mulai melakukan sesuatu dengan file. Anda akan melihat bahwa sekarang kita akan mulai melihat lebih banyak <code>Result</code> di dalam code kita. Itu dikarenakan saat kita mulai bekerja dengan file dan hal semacamnya, besar kemungkinan kita melakukan kesalahan. Bisa saja mungkin filenya tidak ada di sana (tidak bisa mengaksesnya), atau bisa jadi juga mungkin komputer kita tidak dapat membacanya. </p>
<p>Anda mungkin masih ingat bahwa jika Anda menggunakan operator <code>?</code>, ia akan mengmbalikan <code>Result</code> pada function tempat ia berada. Jika Anda tidak bisa mengingat error typenya, Anda bisa mengosongkannya (dengan <code>()</code>) dan biarkan compiler yang memberitahukannya kepada Anda. Mari kita coda dengan sebuah function yang mencoba untuk membuat sebuah angkan menggunakan method <code>.parse()</code>.</p>
<pre><pre class="playground"><code class="language-rust">// ‚ö†Ô∏è
fn give_number(input: &amp;str) -&gt; Result&lt;i32, ()&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() {
    println!(&quot;{:?}&quot;, give_number(&quot;88&quot;));
    println!(&quot;{:?}&quot;, give_number(&quot;5&quot;));
}
</code></pre></pre>
<p>Compiler memberi tahu kita secara tepat tentang apa yang harus kita lakukan:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src\main.rs:4:5
  |
3 | fn give_number(input: &amp;str) -&gt; Result&lt;i32, ()&gt; {
  |                                --------------- expected `std::result::Result&lt;i32, ()&gt;` because of return type
4 |     input.parse::&lt;i32&gt;()
  |     ^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `std::num::ParseIntError`
  |
  = note: expected enum `std::result::Result&lt;_, ()&gt;`
             found enum `std::result::Result&lt;_, std::num::ParseIntError&gt;`
</code></pre>
<p>Mantap! Jadi kita cukup mengubah returnnya menjadi apa yang compiler katakan:</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn give_number(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() {
    println!(&quot;{:?}&quot;, give_number(&quot;88&quot;));
    println!(&quot;{:?}&quot;, give_number(&quot;5&quot;));
}
</code></pre></pre>
<p>Sekarang programnya berjalan!</p>
<pre><code class="language-text">Ok(88)
Ok(5)
</code></pre>
<p>Jadi sekarang kita ingin menggunakan <code>?</code> agar langsung memberikan valuenya jika programnya berjalan, dan memberikan error jika programnya tidak bisa dijalankan. Tapi bagaimana caranya melakukan hal tersebut di dalam <code>fn main()</code>? Jika kita mencoba untuk menggunakan <code>?</code> di dalam <code>main()</code>, maka ia tidak akan berfungsi.</p>
<pre><pre class="playground"><code class="language-rust">// ‚ö†Ô∏è
use std::num::ParseIntError;

fn give_number(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() {
    println!(&quot;{:?}&quot;, give_number(&quot;88&quot;)?);
    println!(&quot;{:?}&quot;, give_number(&quot;5&quot;)?);
}
</code></pre></pre>
<p>Compiler akan memunculkan ini:</p>
<pre><code class="language-text">error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)
  --&gt; src\main.rs:8:22
   |
7  | / fn main() {
8  | |     println!(&quot;{:?}&quot;, give_number(&quot;88&quot;)?);
   | |                      ^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
9  | |     println!(&quot;{:?}&quot;, give_number(&quot;5&quot;)?);
10 | | }
   | |_- this function should return `Result` or `Option` to accept `?`
</code></pre>
<p>Tapi sebenarnya <code>main()</code> bisa mengembalikan <code>Result</code>, sama seperti function lainnya. Jika function kita bekerja, kita tidak ingin me-return apapun (<code>main()</code> tidak memberikan apapun). Dan jika ia tidak bekerja, ia akan mengembalikan error yang sama. Sehingga kita bisa menuliskan codenya seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">use std::num::ParseIntError;

fn give_number(input: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    input.parse::&lt;i32&gt;()
}

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    println!(&quot;{:?}&quot;, give_number(&quot;88&quot;)?);
    println!(&quot;{:?}&quot;, give_number(&quot;5&quot;)?);
    Ok(())
}
</code></pre></pre>
<p>Jangan lupa <code>Ok(())</code> pada bagian akhir: ini sangatlah umum di Rust. Itu artinya adalah <code>Ok</code> yang di dalamnya ada <code>()</code>, yang mana itu adalah merupakan value kembaliannya. Beginilah outputnya:</p>
<pre><code class="language-text">88
5
</code></pre>
<p>Ini memanglah tidak terlalu berguna di saat kita menggunakan <code>.parse()</code>, namun ia akan berguna ketika kita melakukan sesuatu yang berkaitan dengan file. Ini dikarenakan operator <code>?</code> juga mengubah error typenya. Inilah informasi yang bisa dilihat pada <a href="https://doc.rust-lang.org/std/macro.try.html">laman tentang operator ?</a> yang ditulis dengan simple English:</p>
<pre><code class="language-text">If you get an `Err`, it will get the inner error. Then `?` does a conversion using `From`. With that it can change specialized errors to more general ones. The error it gets is then returned.
</code></pre>
<p>Artinya, &quot;Jika Anda mendapatkan <code>Err</code>, ia akan mendapatkan inner error. Kemudian <code>?</code> melakukan konversi menggunakan <code>From</code>. Dengan itu ia bisa mengubah error yang spesifik menjadi error yang umum. Error yang didapatkan tersebut kemudian dikembalikan.&quot;</p>
<p>Juga, Rust memiliki type <code>Result</code> di saat menggunakan <code>File</code> atau hal semacamnya. Ia biasa disebut <code>std::io::Result</code>, dan ini adalah apa yang biasanya Anda lihat di dalam <code>main()</code> saat Anda menggunakan <code>?</code> untuk membuka dan melakukan sesuatu terhadap file. Itu sebenarnya adalah type alias. Ia terlihat seperti berikut:</p>
<pre><code class="language-text">type Result&lt;T&gt; = Result&lt;T, Error&gt;;
</code></pre>
<p>Jadi ia sebenarnya adalah <code>Result&lt;T, Error&gt;</code>, namun kita hanya perlu menuliskan <code>Result&lt;T&gt;</code>.</p>
<p>Sekarang mari kita coba mengerjakan sesuatu dengan file untuk pertama kalinya. <code>std::fs</code> adalah tempat dimana method-method yang berguna untuk bekerja dengan file berada, dan dengan <code>std::io::Write</code> Anda bisa menuliskan sesuatu ke dalam file tersebut. Dengan <code>std::io::Write</code> kita bisa menggunakan method <code>.write_all()</code> untuk menuliskan sesuatu ke dalam file.</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::io::Write;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut file = fs::File::create(&quot;myfilename.txt&quot;)?; // Buat sebuah file dengan nama ini.
                                                        // PERINGATAN! Jika Anda sudah memiliki file dengan nama tersebut,
                                                        // ia akan menghapus apapun yang ada di dalamnya.
    file.write_all(b&quot;Let's put this in the file&quot;)?;     // Jangan lupa dengan b yang ditulis di depan &quot;. Itu karena file akan mengambil bytenya.
    Ok(())
}
</code></pre></pre>
<p>Kemudian jika Anda klik pada file baru tersebut (<code>myfilename.txt</code>), di dalamnya akan ada tulisan <code>Let's put this in the file</code>.</p>
<p>Sebenarnya kita tidak perlu melakukannya dengan menuliskannya dalam 2 baris seperti itu, karena kita menggunakan operator <code>?</code>. Ia akan pass hasil yang kita inginkan jika ia bekerja, seperti saat kita menggunakan banyak metode pada iterator. Di sinilah kita mendapatkan &quot;kenyamanan&quot; saat menggunakan operator <code>?</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::io::Write;

fn main() -&gt; std::io::Result&lt;()&gt; {
    fs::File::create(&quot;myfilename.txt&quot;)?.write_all(b&quot;Let's put this in the file&quot;)?;
    Ok(())
}
</code></pre></pre>
<p>Jadi, bahasa mudahnya adalah &quot;Tolong coba buatkan sebuah file dan periksa apakah kita berhasil membuatnya. Jika ya, kemudian gunakan <code>.write_all()</code> untuk menulis sesuatu di dalamnya dan kemudian periksa apakah kita berhasil menuliskannya.&quot;</p>
<p>Dan sebenarnya, ada juga function yang melakukan keduanya secara bersamaan (membuat file sekaligus menuliskan sesuatu di dalamnya). Ia adalah <code>std::fs::write</code>. Di dalamnya, Anda memberikan nama file yang Anda inginkan, dan juga isi/tulisan yang ingin Anda masukkan ke dalamnya. Lagi-lagi, berhati-hatilah! Ia akan menghapus apapun yang ada di dalam file tersebut jika sebelumnya file tersebut sudah ada. Juga, method ini memungkinkan kita menuliskan <code>&amp;str</code> tanpa <code>b</code> di bagian depannya, karena beginilah signaturenya:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn write&lt;P: AsRef&lt;Path&gt;, C: AsRef&lt;[u8]&gt;&gt;(path: P, contents: C) -&gt; Result&lt;()&gt;
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRef&lt;[u8]&gt;</code> adalah alasan mengapa Anda bisa menuliskannya tanpa menuliskan <code>b</code> di depannya.</p>
<p>Penggunaannya pun sangat sederhana:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;

fn main() -&gt; std::io::Result&lt;()&gt; {
    fs::write(&quot;calvin_with_dad.txt&quot;, 
&quot;Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>Jadi, itu merupakan file yang akan kita gunakan. Isinya adalah percakapan antara tokoh fiktif bernama Calvin dan juga ayahnya, yang menjawab pertanyaan anaknya dengan tidak serius. Dengan cara ini, kita bisa membuat sebuah file untuk digunakan setiap saat.</p>
<p>Membuka file sama mudahnya seperti membuat file. Anda cukup menggunakan <code>open()</code>. Setelah itu (jika filenya ditemukan), Anda bisa melakukan sesuatu seperti <code>read_to_string()</code>. Untuk melakukan itu Anda bisa membuat sebuah <code>String</code> yang mutable dan membaca filenya di dalam situ. Codenya menjadi seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::fs::File;
use std::io::Read; // untuk menggunakan function .read_to_string()

fn main() -&gt; std::io::Result&lt;()&gt; {
     fs::write(&quot;calvin_with_dad.txt&quot;, 
&quot;Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...&quot;)?;


    let mut calvin_file = File::open(&quot;calvin_with_dad.txt&quot;)?; // Buka file yang kita buat
    let mut calvin_string = String::new(); // String ini akan menyimpannya
    calvin_file.read_to_string(&amp;mut calvin_string)?; // baca filenya dan letakkan di dalam mutable Stringnya

    calvin_string.split_whitespace().for_each(|word| print!(&quot;{} &quot;, word.to_uppercase())); // melakukan sesuatu dengan String tersebut

    Ok(())
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">CALVIN: DAD, HOW COME OLD PHOTOGRAPHS ARE ALWAYS BLACK AND WHITE? DIDN'T THEY HAVE COLOR FILM BACK THEN? DAD: SURE THEY DID. IN 
FACT, THOSE PHOTOGRAPHS *ARE* IN COLOR. IT'S JUST THE *WORLD* WAS BLACK AND WHITE THEN. CALVIN: REALLY? DAD: YEP. THE WORLD DIDN'T TURN COLOR UNTIL SOMETIMES IN THE 1930S...
</code></pre>
<p>Okay, bagaimana jika kita ingin membuat sebuah file namun kita tidak akan melakukannya jika di situ sudah ada file lainnya dengan nama yang sama? Mungkin Anda tidak ingin menghapus file lain tersebut (jika ia sudah terlebih dahulu ada disana), hanya karena ingin membuat satu file yang baru. Untuk melakukan ini, ada struct yang bernama <code>OpenOptions</code>. Sebenarnya, kita sudah menggunakan <code>OpenOptions</code> selama ini dan kita tidak mengetahuinya. Coba lihatlah source code dari <code>File::open</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt; {
        OpenOptions::new().read(true).open(path.as_ref())
    }
<span class="boring">}
</span></code></pre></pre>
<p>Menarik, ini mirip dengan builder pattern yang sebelumnya kita pelajari. Sama pula dengan <code>File::create</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt; {
        OpenOptions::new().write(true).create(true).truncate(true).open(path.as_ref())
    }
<span class="boring">}
</span></code></pre></pre>
<p>Jika Anda pergi ke <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html">laman tentang OpenOptions</a>, Anda bisa melihat semua method yang bisa Anda gunakan. Kebanyakan method tersebut akan mengambil inputan <code>bool</code>:</p>
<ul>
<li><code>append()</code>: Ini berarti &quot;tambahkan ke isi file tersebut (yang mana filenya sudah ada disana) alih-alih menghapus isinya&quot;.</li>
<li><code>create()</code>: Ini memungkinkan <code>OpenOptions</code> membuat sebuah file.</li>
<li><code>create_new()</code>: Ini berarti ia akan hanya membuat filenya jika filenya memang belum ada.</li>
<li><code>read()</code>: Ubah ia menjadi <code>true</code> jika Anda ingin method tersebut bisa membaca sebuah file.</li>
<li><code>truncate()</code>: Ubah ia menjadi <code>true</code> jika Anda ingin memotong isi dari filenya sampai ke 0 (menghapus isinya) di saat Anda membuka filenya.</li>
<li><code>write()</code>: memungkinkan Anda menulis ke dalam file.</li>
</ul>
<p>Dan kemudian, ada <code>.open()</code> dengan nama filenya, dan ia akan mengembalikan <code>Result</code>. Code di bawah ini adalah contohnya:</p>
<pre><pre class="playground"><code class="language-rust">// ‚ö†Ô∏è
use std::fs;
use std::fs::OpenOptions;

fn main() -&gt; std::io::Result&lt;()&gt; {
     fs::write(&quot;calvin_with_dad.txt&quot;, 
&quot;Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...&quot;)?;

    let calvin_file = OpenOptions::new().write(true).create_new(true).open(&quot;calvin_with_dad.txt&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>Pertama-tama, kita membuat sebuah <code>OpenOptions</code> menggunakan <code>new</code> (selalu dimulai dengan <code>new</code>). Kemudian kita memberikannya &quot;kemampuan&quot; untuk menulis (menggunakan <code>write</code>). Setelah itu, kita ubah <code>create_new()</code> menjadi <code>true</code>, dan mencoba membuka file yang kita buat. Dan ini tidak akan berhasil, sesuai seperti yang kita inginkan (karena sudah ada file dengan nama yang sama sebelumnya):</p>
<pre><code class="language-text">Error: Os { code: 80, kind: AlreadyExists, message: &quot;The file exists.&quot; }
</code></pre>
<p>Mari kita coba menggunakan <code>.append()</code> untuk menuliskan sesuatu ke dalam file yang sudah ada itu. Untuk menulis ke dalam file, kita bisa menggunakan <code>.write_all()</code>, yang mana itu adalah method yang mencoba menuliskan apapun inputan yang kita berikan.</p>
<p>Dan juga, kita akan menggunakan macro <code>write!</code> untuk melakukan hal yang sama. Anda akan mengingat macro ini dari saat kita menggunakan <code>impl Display</code> untuk struct yang kita buat. Kali ini kita menggunakannya pada file.</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::fs::OpenOptions;
use std::io::Write;

fn main() -&gt; std::io::Result&lt;()&gt; {
    fs::write(&quot;calvin_with_dad.txt&quot;, 
&quot;Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...&quot;)?;

    let mut calvin_file = OpenOptions::new()
        .append(true) // Now we can write without deleting it
        .read(true)
        .open(&quot;calvin_with_dad.txt&quot;)?;
    calvin_file.write_all(b&quot;And it was a pretty grainy color for a while too.\n&quot;)?;
    write!(&amp;mut calvin_file, &quot;That's really weird.\n&quot;)?;
    write!(&amp;mut calvin_file, &quot;Well, truth is stranger than fiction.&quot;)?;

    println!(&quot;{}&quot;, fs::read_to_string(&quot;calvin_with_dad.txt&quot;)?);

    Ok(())
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">Calvin: Dad, how come old photographs are always black and white? Didn't they have color film back then?
Dad: Sure they did. In fact, those photographs *are* in color. It's just the *world* was black and white then.
Calvin: Really?
Dad: Yep. The world didn't turn color until sometimes in the 1930s...And it was a pretty grainy color for a while too.
That's really weird.
Well, truth is stranger than fiction.
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Chapter_64.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="Chapter_66.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Chapter_64.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="Chapter_66.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
