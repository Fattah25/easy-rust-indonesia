<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> A tour of the standard library - Easy Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong> Updates</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong> Who am I?</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong> Catatan dari translator</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong> Writing Rust in Easy English</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong> Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong> üöß and ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong> Comments</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong> Types</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong> Type inference</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong> Printing 'hello, world!'</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong> Display and debug</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong> Mutability (changing)</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong> The stack, the heap, and pointers</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong> More about printing</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong> Strings</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong> const and static</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong> More on references</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong> Mutable references</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong> Giving references to functions</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong> Copy types</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong> Collection types</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong> Control flow</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong> Structs</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong> Enums</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong> Loops</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong> Implementing structs and enums</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong> Destructuring</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong> References and the dot operator</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong> Generics</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong> Option and Result</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong> Other collections</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong> The ? operator</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong> Traits</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong> Chaining methods</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong> Closures</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong> The dbg! macro and .inspect</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong> Types of &amp;str</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong> Cow</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong> The todo! macro</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong> Rc</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong> Multiple threads</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong> Closures in functions</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong> Arc</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong> Channels</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong> Reading Rust documentation</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong> Box</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong> Box around traits</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong> Default and the builder pattern</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong> Deref and DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong> Crates and modules</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong> Testing</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong> External crates</a></li><li class="chapter-item expanded "><a href="Chapter_61.html" class="active"><strong aria-hidden="true">62.</strong> A tour of the standard library</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong> Writing macros</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong> cargo</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong> Taking user input</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong> Using files</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="Chapter_67.html"><strong aria-hidden="true">68.</strong> The end?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Easy Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="a-tour-of-the-standard-library"><a class="header" href="#a-tour-of-the-standard-library">A tour of the standard library</a></h2>
<p>Sekarang setelah Anda mengetahu banyak hal tentang Rust, Anda akan dapat memahami sebagian besar hal yang ada di dalam standard library. Code yang berada di dalamnya tidaklah lagi terlihat begitu menakutkan. Mari kita lihat beberapa bagian di dalamnya yang belum kita pelajari. Tour ini akan membahas sebagain besar standard library yang mana tidak perlu lagi Anda install di Rust. Kita akan meninjau ulang banyak hal yang telah kita ketahui sehingga kita dapat mempelajarinya dengan pemahaman yang lebih baik.</p>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Satu hal yang perlu dicatat tentang array adalah bahwa mereka tidak mengimplementasikan <code>Iterator.</code>. Yang artinya, jika kita memiliki array, Anda tidak bisa menggunakan <code>for</code>. Tapi Anda bisa menggunakan method seperti <code>.iter()</code> pada array. Atau Anda bisa menggunakan <code>&amp;</code> untuk mendapatkan slicenya. Sebenarnya compiler akan memberitahukannya jika Anda mencoba untuk menggunakan <code>for</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // ‚ö†Ô∏è
    let my_cities = [&quot;Beirut&quot;, &quot;Tel Aviv&quot;, &quot;Nicosia&quot;];

    for city in my_cities {
        println!(&quot;{}&quot;, city);
    }
}
</code></pre></pre>
<p>Pesan errornya adalah:</p>
<pre><code class="language-text">error[E0277]: `[&amp;str; 3]` is not an iterator
 --&gt; src\main.rs:5:17
  |
  |                 ^^^^^^^^^ borrow the array with `&amp;` or call `.iter()` on it to iterate over it
</code></pre>
<p>Jadi, kita coba keduanya. Keduanya memberikan hasil yang sama.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_cities = [&quot;Beirut&quot;, &quot;Tel Aviv&quot;, &quot;Nicosia&quot;];

    for city in &amp;my_cities {
        println!(&quot;{}&quot;, city);
    }
    for city in my_cities.iter() {
        println!(&quot;{}&quot;, city);
    }
}
</code></pre></pre>
<p>Hasil cetaknya adalah:</p>
<pre><code class="language-text">Beirut
Tel Aviv
Nicosia
Beirut
Tel Aviv
Nicosia
</code></pre>
<p>Jika Anda ingin mendapatkan variabel dari array, Anda bisa meletakkan nama variabelnya di dalam <code>[]</code> untuk melakukan destructure. Ini sama seperti menggunakan sebuah tuple di dalam statement <code>match</code> atau mengambil variabel dari sebuah struct.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_cities = [&quot;Beirut&quot;, &quot;Tel Aviv&quot;, &quot;Nicosia&quot;];
    let [city1, city2, city3] = my_cities;
    println!(&quot;{}&quot;, city1);
}
</code></pre></pre>
<p>Hasil cetaknya adalah <code>Beirut</code>.</p>
<h3 id="char"><a class="header" href="#char">char</a></h3>
<p>Anda bisa menggunakan method <code>.escape_unicode()</code> untuk mendapatkan angka Unicode dari sebuah <code>char</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let korean_word = &quot;Ï≤≠Ï∂òÏòàÏ∞¨&quot;;
    for character in korean_word.chars() {
        print!(&quot;{} &quot;, character.escape_unicode());
    }
}
</code></pre></pre>
<p>Hasil cetaknya adalah <code>\u{ccad} \u{cd98} \u{c608} \u{cc2c}</code>.</p>
<p>Anda bisa mendapatkan char dari <code>u8</code> menggunakan trait <code>From</code>, namun untuk <code>u32</code> Anda perlu menggunakan <code>TryFrom</code> karena bisa saja ia gagal. Ada banyak angka di <code>u32</code> daripada seluruh karakter yang ada di Unicode. Kita bisa melihat ini dengan contoh yang sederhana.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::TryFrom; // Anda perlu menggunakan TryFrom
use rand::prelude::*;      // kita akan menggunakan angka random juga

fn main() {
    let some_character = char::from(99); // Untuk hal ini sangatlah mudah dilakukan - tidak perlu menggunakan TryFrom
    println!(&quot;{}&quot;, some_character);

    let mut random_generator = rand::thread_rng();
    // Ia akan mencoba 40,000 kali untuk membuat sebuah char dari u32.
    // Range loopnya adalah dari 0 (std::u32::MIN) sampai ke angka terbesar di u32 (std::u32::MAX). Jika ia tidak bekerja, kita akan memberinya '-'.
    for _ in 0..40_000 {
        let bigger_character = char::try_from(random_generator.gen_range(std::u32::MIN..std::u32::MAX)).unwrap_or('-');
        print!(&quot;{}&quot;, bigger_character)
    }
}
</code></pre></pre>
<p>Hampir setiap saat ia akan men-generate <code>-</code>. Ini adalah bagian dari output yang akan Anda lihat:</p>
<pre><code class="language-text">------------------------------------------------------------------------§í∞---------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-------------------------------------------------------------Ï∂ó--------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
------------Úáçú----------------------------------------------------
</code></pre>
<p>Jadi, adalah hal yang baik jika Anda perlu menggunakan <code>TryFrom</code>.</p>
<p>Juga, sebagaimana pada rilis di akhir Agustus 2020, Anda sekarang bisa mendapatkan <code>String</code> dari <code>char</code>. (<code>String</code> mengimplementasikan <code>From&lt;char&gt;</code>) Cukup tuliskan <code>String::from()</code> dan letakkan <code>char</code> di dalamnya.</p>
<h3 id="integers"><a class="header" href="#integers">Integers</a></h3>
<p>Ada banyak method matematis untuk type ini, ditambah dengan method-method lainnya. Berikut adalah beberapa method yang paling berguna.</p>
<p><code>.checked_add()</code>, <code>.checked_sub()</code>, <code>.checked_mul()</code>, <code>.checked_div()</code>. Ini merupakan method yang baik jika Anda berpikir bahwa Anda mungkin mendapatkan angka yang tidak cocok dengan sebuah type. Method-method tersebut akan mengembalikan <code>Option</code> sehingga Anda bisa dengan aman memeriksa apakah operasi matematika yang Anda lakukan bekerja tanpa membuat programnya menjadi panic.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let some_number = 200_u8;
    let other_number = 200_u8;

    println!(&quot;{:?}&quot;, some_number.checked_add(other_number));
    println!(&quot;{:?}&quot;, some_number.checked_add(1));
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">None
Some(201)
</code></pre>
<p>Anda pasti menyadari pada laman tentang integer, banyak tertulis <code>rhs</code>. Ini berarti &quot;right hand side&quot;, yang artinya adalah sisi sebelah kanan di saat Anda melakukan beberapa operasi matematika. Contohnya, di <code>5 + 6</code>, <code>5</code> ada di sebelah kiri dan <code>6</code> ada di sebelah kanan. Nah, itulah <code>rhs</code>. Ini bukanlah sebuah keyword, namun Anda akan sering melihatnya, sehingga ini adalah hal yang penting untuk Anda ketahui.</p>
<p>Sementara kita membahas topik ini, mari mempelajari tentang bagaimana mengimplementasikan <code>Add</code>. Setelah Anda mengimplementasikan <code>Add</code>, Anda bisa menggunakan <code>+</code> pada type yang kita buat. Anda perlu untuk mengimplementasikan <code>Add</code> sendiri karena &quot;add&quot; bisa berarti banyak hal. Berikut adalah contoh yang ada pada laman standard library:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add; // pertama-tama, kita import Add

#[derive(Debug, Copy, Clone, PartialEq)] // PartialEq mungkin adalah bagian yang paling penting pada bagian ini. Anda ingin bisa membandingkan angka
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Self; // Ingat, ini disebut sebagai &quot;associated type&quot;: a &quot;type yang berjalan bersamaan&quot;.
                        // Pada kasus ini, ia hanyalah sebuah Point

    fn add(self, other: Self) -&gt; Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Sekarang mari implementasikan <code>Add</code> untuk type yang kita buat. Mari kita bayangkan bahwa kita ingin menambahkan dua negara bersamaan sehingga kita bisa membandingkan ekonominya. Berikut adalah codenya:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;
use std::ops::Add;

#[derive(Clone)]
struct Country {
    name: String,
    population: u32,
    gdp: u32, // ini adalah ukuran ekonominya
}

impl Country {
    fn new(name: &amp;str, population: u32, gdp: u32) -&gt; Self {
        Self {
            name: name.to_string(),
            population,
            gdp,
        }
    }
}

impl Add for Country {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {
            name: format!(&quot;{} and {}&quot;, self.name, other.name), // Kita akan menambahkan namanya bersama-sama,
            population: self.population + other.population, // dan populasinya,
            gdp: self.gdp + other.gdp,   // dan juga GDPnya
        }
    }
}

impl fmt::Display for Country {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            &quot;In {} are {} people and a GDP of ${}&quot;, // Kemudian kita bisa print semuanya hanya dengan menggunakan {}
            self.name, self.population, self.gdp
        )
    }
}

fn main() {
    let nauru = Country::new(&quot;Nauru&quot;, 10_670, 160_000_000);
    let vanuatu = Country::new(&quot;Vanuatu&quot;, 307_815, 820_000_000);
    let micronesia = Country::new(&quot;Micronesia&quot;, 104_468, 367_000_000);

    // Kita bisa memberikan Country sebuah &amp;str sebagai ganti String untuk namanya. Tapi kita harus menuliskan lifetimenya dimana-mana
    // dan itu terlalu berlebihan untuk contoh yang sederhana. Lebih baik cukup clone saja di saat kita memanggil println!.
    println!(&quot;{}&quot;, nauru.clone());
    println!(&quot;{}&quot;, nauru.clone() + vanuatu.clone());
    println!(&quot;{}&quot;, nauru + vanuatu + micronesia);
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">In Nauru are 10670 people and a GDP of $160000000
In Nauru and Vanuatu are 318485 people and a GDP of $980000000
In Nauru and Vanuatu and Micronesia are 422953 people and a GDP of $1347000000
</code></pre>
<p>Nantinya di code ini kita bisa mengubah <code>.fmt()</code> untuk menampilkan angka yang lebih mudah dibaca.</p>
<p>Tiga trait lainnya adalah <code>Sub</code>, <code>Mul</code>, dan <code>Div</code>. Dan pada dasarnya, ketiganya sama pengimplementasiannya. Untuk <code>+=</code>, <code>-=</code>, <code>*=</code> dan <code>/=</code>, cukup tambahkan <code>Assign</code>: <code>AddAssign</code>, <code>SubAssign</code>, <code>MulAssign</code>, dan <code>DivAssign</code>. Anda bisa melihat daftarnya <a href="https://doc.rust-lang.org/std/ops/index.html#structs">disini</a>, karena masih ada banyak lagi. Contohnya, <code>%</code> disebut dengan <code>Rem</code>, <code>-</code> disebut dengan <code>Neg</code>, dll.</p>
<h3 id="floats"><a class="header" href="#floats">Floats</a></h3>
<p><code>f32</code> dan <code>f64</code> memiliki method yang sangat banyak yang bisa Anda gunakan di saat Anda melakukan operasi matematis. Kita tidak akan mempelajari semuanya, namun ini adalah beberapa method yang mungkin nantinya Anda gunakan. Mereka adalah: <code>.floor()</code>, <code>.ceil()</code>, <code>.round()</code>, dan <code>.trunc()</code>. Semua method tersebut mengembalikan <code>f32</code> atau <code>f64</code> yang mirip seperti integer, namun dengan angka <code>0</code> setelah titik. Inilah yang dilakukan oleh method-method tersebut:</p>
<ul>
<li><code>.floor()</code>: memberikan Anda integer terkecil.</li>
<li><code>.ceil()</code>: memberikan Anda integer terbesar.</li>
<li><code>.round()</code>: memberikan Anda integer terbesar jika angkanya bernilai 0.5 atau lebih, atau angka yang sama jika ia kurang dari 0.5. Ini disebut sebagai &quot;rounding&quot; (pembulatan) karena ia memberikan angka &quot;yang dibulatkan&quot; (angka yang memiliki bentuk yang pendek, sederhana).</li>
<li><code>.trunc()</code>: memotong angka setelah titik. Truncate artinya &quot;memotong&quot;.</li>
</ul>
<p>Ini adalah function sederhana untuk mencetak hasil dari method-method tersebut.</p>
<pre><pre class="playground"><code class="language-rust">fn four_operations(input: f64) {
    println!(
&quot;For the number {}:
floor: {}
ceiling: {}
rounded: {}
truncated: {}\n&quot;,
        input,
        input.floor(),
        input.ceil(),
        input.round(),
        input.trunc()
    );
}

fn main() {
    four_operations(9.1);
    four_operations(100.7);
    four_operations(-1.1);
    four_operations(-19.9);
}
</code></pre></pre>
<p>Hasil cetaknya adalah:</p>
<pre><code class="language-text">For the number 9.1:
floor: 9
ceiling: 10
rounded: 9 // because less than 9.5
truncated: 9

For the number 100.7:
floor: 100
ceiling: 101
rounded: 101 // because more than 100.5
truncated: 100

For the number -1.1:
floor: -2
ceiling: -1
rounded: -1
truncated: -1

For the number -19.9:
floor: -20
ceiling: -19
rounded: -20
truncated: -19
</code></pre>
<p><code>f32</code> dan <code>f64</code> memiliki method bernama <code>.max()</code> dan <code>.min()</code> yang memberikan Anda nilai tertinggi atau nilai terendah dari dua buah angka. (Untuk type yang lain, Anda bisa menggunakan <code>std::cmp::max</code> dan <code>std::cmp::min</code>.) Berikut ini adalah cara menggunakan method-method tersebut dengan method <code>.fold()</code> untuk mendapatkan nilai tertinggi atau terendah. Anda bisa melihat lagi bahwa method <code>.fold()</code> tidak hanya digunakan untuk menambahkan angka.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let my_vec = vec![8.0_f64, 7.6, 9.4, 10.0, 22.0, 77.345, 10.22, 3.2, -7.77, -10.0];
    let maximum = my_vec.iter().fold(f64::MIN, |current_number, next_number| current_number.max(*next_number)); // Catatan: mulai dengan angka terkecil di f64.
    let minimum = my_vec.iter().fold(f64::MAX, |current_number, next_number| current_number.min(*next_number)); // Dan pada bagian ini, mulai dengan angka terbesar di f64
    println!(&quot;{}, {}&quot;, maximum, minimum);
}
</code></pre></pre>
<h3 id="bool"><a class="header" href="#bool">bool</a></h3>
<p>Di Rust, Anda bisa mengubah <code>bool</code> menjadi sebuah integer jika Anda menginginkannya, karena hal itu aman untuk dilakukan. Namun Anda tidak bisa melakukan hal tersebut sebaliknya. Seperti yang Anda lihat, <code>true</code> diubah menjadi 1 dan <code>false</code> diubah menjadi 0.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_false = (true, false);
    println!(&quot;{} {}&quot;, true_false.0 as u8, true_false.1 as i32);
}
</code></pre></pre>
<p>Hasil cetaknya adalah <code>1 0</code>. Atau Anda bisa menggunakan <code>.into()</code> jika Anda memberitahukan typenya ke compiler:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_false: (i128, u16) = (true.into(), false.into());
    println!(&quot;{} {}&quot;, true_false.0, true_false.1);
}
</code></pre></pre>
<p>Hasil cetaknya sama seperti yang di atas.</p>
<p>Dengan rilir Rust 1.50 (rilis pada Februari 2021), sekarang ada method bernama <code>then()</code>, yang mana mengubah <code>bool</code> menjadi <code>Option</code>. Dengan method <code>then()</code>, Anda menuliskan sebuah closure, dan closurenya dipanggil jika itemnya bernilai <code>true</code>. Juga, apapun yang di return dari closure tersebut akan dimasukkan ke dalam <code>Option</code>. Ini adalah contoh sederhananya:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let (tru, fals) = (true.then(|| 8), false.then(|| 8));
    println!(&quot;{:?}, {:?}&quot;, tru, fals);
}
</code></pre></pre>
<p>Hasil cetaknya adalah <code>Some(8), None</code>.</p>
<p>Dan yang di bawah ini merupakan contohnya yang agak rumit:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let bool_vec = vec![true, false, true, false, false];
    
    let option_vec = bool_vec
        .iter()
        .map(|item| {
            item.then(|| { // masukkan ke dalam map sehingga kita bisa pass item tersebut
                println!(&quot;Got a {}!&quot;, item);
                &quot;It's true, you know&quot; // Ini akan masuk ke dalam Some jika ia true
                                      // sebaliknya, ia akan menghasilkan None
            })
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;Now we have: {:?}&quot;, option_vec);

    // Ia akan mencetak None juga. Mari kita gunakan filter_map ke vector tersebut dan kumpulkan hasilnya di Vec yang baru.
    let filtered_vec = option_vec.into_iter().filter_map(|c| c).collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;And without the Nones: {:?}&quot;, filtered_vec);
}
</code></pre></pre>
<p>Dan ini adalah hasil cetaknya:</p>
<pre><code class="language-text">Got a true!
Got a true!
Now we have: [Some(&quot;It\'s true, you know&quot;), None, Some(&quot;It\'s true, you know&quot;), None, None]
And without the Nones: [&quot;It\'s true, you know&quot;, &quot;It\'s true, you know&quot;]
</code></pre>
<h3 id="vec"><a class="header" href="#vec">Vec</a></h3>
<p>Vec memiliki banyak method yang sama sekali kita pelajari untuk sekarang ini. Kita mulai dari <code>.sort()</code>. <code>.sort()</code> menggunakan <code>&amp;mut self</code> untuk menyortir vector.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![100, 90, 80, 0, 0, 0, 0, 0];
    my_vec.sort();
    println!(&quot;{:?}&quot;, my_vec);
}
</code></pre></pre>
<p>Hasil cetaknya adalah <code>[0, 0, 0, 0, 0, 80, 90, 100]</code>. Namun yang lebih menarik adalah ada cara lain untuk menyortir yaitu <code>.sort_unstable()</code>, dan ia biasanya lebih cepat. Ia bisa menjadi lebih cepat karena ia tidak peduli tentang urutan angkanya jika angkanya sama. Pada <code>.sort()</code>, Anda tahu bahwa bagian akhir vector <code>0, 0, 0, 0, 0</code> akan berada pada urutan yang sama setelah melakukan <code>.sort()</code>. Namun <code>.sort_unstable()</code> mungkin memndahkan nol terakhir ke index 0, kemudian nol terakhir yang ke-3 di pindah ke index 2, dst.</p>
<p><code>.dedup()</code> artinya &quot;de-duplicate&quot;. Ia akan menghapus item yang sama dalam sebuah vector, namun hanya jika mereka bersebelahana. Code di bawah ini tidak hanya mencetak <code>&quot;sun&quot;, &quot;moon&quot;</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![&quot;sun&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;];
    my_vec.dedup();
    println!(&quot;{:?}&quot;, my_vec);
}
</code></pre></pre>
<p>Ia hanya akan menghapus &quot;sun&quot; yang berada di sebelah &quot;sun&quot;, kemudian menghapus &quot;moon&quot; yang berada di sebelah &quot;moon&quot;, dan kemudian lagi dengan &quot;moon&quot; yang bersebelahan dengan &quot;moon&quot;. Maka hasilnya adalah: <code>[&quot;sun&quot;, &quot;moon&quot;, &quot;sun&quot;, &quot;moon&quot;]</code>.</p>
<p>Jika Anda ingin menghapus setiap duplikat, maka lakukan <code>.sort()</code> terlebih dahulu:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_vec = vec![&quot;sun&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;, &quot;sun&quot;, &quot;moon&quot;, &quot;moon&quot;];
    my_vec.sort();
    my_vec.dedup();
    println!(&quot;{:?}&quot;, my_vec);
}
</code></pre></pre>
<p>Maka hasilnya adalah: <code>[&quot;moon&quot;, &quot;sun&quot;]</code>.</p>
<h3 id="string"><a class="header" href="#string">String</a></h3>
<p>Anda akan mengingat bahwa <code>String</code> adalah type yang mirip dengan <code>Vec</code>. Ia mirip seperti <code>Vec</code> Anda bisa melakukan banyak hal dengan method yang sama. Contohnya, Anda bisa menggunakan <code>String::with_capacity()</code>. Anda mungkin akan memerlukannya jika Anda selalu melakukan push pada <code>char</code>menggunakan <code>.push()</code> atau melakukan push terhadap <code>&amp;str</code> dengan menggunakan <code>.push_str()</code>. Ini adalah sebuah contoh dari <code>String</code> yang terlalu banyak melakukan alokasi.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::new();
    let mut capacity_counter = 0; // kapasitasnya dimulai dari 0
    for _ in 0..100_000 { // lakukan sebanyak 100,000 kali
        if push_string.capacity() != capacity_counter { // Pertama, periksa apakah kapasitasnya sekarang telah berbeda
            println!(&quot;{}&quot;, push_string.capacity()); // Jika ya, cetak kapasitasnya
            capacity_counter = push_string.capacity(); // kemudian perbarui counternya
        }
        push_string.push_str(&quot;I'm getting pushed into the string!&quot;); // dan push &amp;str ini setiap loopnya berulang
    }
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">35
70
140
280
560
1120
2240
4480
8960
17920
35840
71680
143360
286720
573440
1146880
2293760
4587520
</code></pre>
<p>Kita telah melakukan realokasi (menyalin secara keseluruhan) sebanyak 18 kali. Namun sekarang kita tahu berapa kapasitas akhirnya yang terpakai. Sehingga kita bisa langsung memberikan batas kapasitasnya, dan kita tidak perlu lagi untuk melakukan realokasi: cukup memerlukan satu buah <code>String</code> dengan kapasitas yang muat untuk menyimpan semuanya sampai akhir.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::with_capacity(4587520); // Kita mengetahui kapasitasnya secara tepat. Beberapa ukuran besar yang berbeda juga bisa dipakai
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!(&quot;{}&quot;, push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str(&quot;I'm getting pushed into the string!&quot;);
    }
}
</code></pre></pre>
<p>Dan ia mencetak hanya sekali, yaitu <code>4587520</code>. Sempurna! Kita tidak perlu melakukan alokasi lagi.</p>
<p>Tentu saja, panjang sebenarnya pasti lebih kecil dari ini. Jika Anda mencoba 100,001 kali, 101,000 kali, dst., ia akan tetap mencetak <code>4587520</code>. Ini dikarenakan setiap kali kapasitasnya bertambah, ia bertambah dua kali lipat dari yang sebelumnya. Kita bisa mengecilkannya menggunakan method <code>.shrink_to_fit()</code> (sama juga dengan <code>Vec</code>). <code>String</code> yang kita miliki sangatlah besar dan kita tidak ingin menambahkan apa-apa lagi ke <code>String</code> tersebut, sehingga kita bisa membuatnya menjadi lebih kecil dari yang sebelumnya. Tapi lakukan hal ini jika Anda sudah merasa yakin. Inilah alasannya:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut push_string = String::with_capacity(4587520);
    let mut capacity_counter = 0;
    for _ in 0..100_000 {
        if push_string.capacity() != capacity_counter {
            println!(&quot;{}&quot;, push_string.capacity());
            capacity_counter = push_string.capacity();
        }
        push_string.push_str(&quot;I'm getting pushed into the string!&quot;);
    }
    push_string.shrink_to_fit();
    println!(&quot;{}&quot;, push_string.capacity());
    push_string.push('a');
    println!(&quot;{}&quot;, push_string.capacity());
    push_string.shrink_to_fit();
    println!(&quot;{}&quot;, push_string.capacity());
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">4587520
3500000
7000000
3500001
</code></pre>
<p>Jadi pertama kita memiliki ukuran kapasitas <code>4587520</code>, namun kita tidak menggunakan semuanya. Kita gunakan method <code>.shrink_to_fit()</code> dan mendapatkan kapasitasnya mengecil menjadi <code>3500000</code>. Tapi kemudian kita lupa bahwa kita perlu melakukan push sebuah karakter <code>a</code>. Di saat kita melakukan hal tersebut, Rust melihat bahwa kita memerlukan space lebih dan memberikan kita ukuran dua kali lipat dari sebelumnya: sekarang ia menjadi <code>7000000</code>. Whoops! Sehingga kita menggunakan <code>.shrink_to_fit()</code> lagi dan sekarang kapasitasnya kembali turun menjadi <code>3500001</code>.</p>
<p><code>.pop()</code> bekerja juga pada <code>String</code>, sama seperti saat digunakan pada <code>Vec</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;.daer ot drah tib elttil a si gnirts sihT&quot;);
    loop {
        let pop_result = my_string.pop();
        match pop_result {
            Some(character) =&gt; print!(&quot;{}&quot;, character),
            None =&gt; break,
        }
    }
}
</code></pre></pre>
<p>Hasil cetaknya adalah <code>This string is a little bit hard to read.</code> karena ia dimulai dari karakter yang terakhir.</p>
<p><code>.retain()</code> adalah method yang menggunakan closure, yang mana <code>String</code> jarang sekali memiliki method seperti ini. Ia mirip seperti <code>.filter()</code> untuk iterator.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut my_string = String::from(&quot;Age: 20 Height: 194 Weight: 80&quot;);
    my_string.retain(|character| character.is_alphabetic() || character == ' '); // Tetap simpan jika ia adalah huruf atau spasi
    dbg!(my_string); // Mari kali ini kita iseng menggunakan dbg!() menggantikan println!
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">[src\main.rs:4] my_string = &quot;Age  Height  Weight &quot;
</code></pre>
<h3 id="osstring-and-cstring"><a class="header" href="#osstring-and-cstring">OsString and CString</a></h3>
<p><code>std::ffi</code> adalah bagian dari <code>std</code> yang membantu Anda untuk menghubungkan Rust dengan bahasa lain atau operating system yang lain. Ia memiliki type seperti <code>OsString</code> dan <code>CString</code>, yang mana mirip seperti <code>String</code> yang ada pada operating system atau <code>String</code> untuk bahasa C. Masing-masing dari mereka memiliki type <code>&amp;str</code>nya sendiri juga: yaitu <code>OsStr</code> dan <code>CStr</code>. <code>ffi</code> adalah singkatan dari &quot;foreign function interface&quot;.</p>
<p>Anda bisa menggunakan <code>OsString</code> di saat Anda bekerja dengan operating system yang tidak memiliki Unicode. Semua string di Rust adalah unicode. Hanya saja, tidak semua operating system memilikinya. Ini adalah penjelasan sederhana dari standard library tentang mengapa kita perlu <code>OsString</code>:</p>
<ul>
<li>String di Unix (Linux, etc.) mungkin saja memiliki banyak byte yang sama sekali tidak memiliki angka 0. Dan terkadang Anda membacanya sebagai Unicode UTF-8.</li>
<li>String di Windows bisa saja dibuat dari random 16-bit yang tidak memiliki angka 0.Dan terkadang Anda membacanya sebagai Unicode UTF-16.</li>
<li>Di Rust, string selalu valid sebagai UTF-8, yang mungkin saja mengandung angka 0.</li>
</ul>
<p>Jadi <code>OsString</code> dibuat agar bisa dibaca oleh semua operating system tersebut.</p>
<p>Anda bisa melakukan semua hal-hal umum dengan menggunakan <code>OsString</code> seperti <code>OsString::from(&quot;Write something here&quot;)</code>. Ia juga memiliki method <code>.into_string()</code> yang mana ia akan mencoba untuk mengubah <code>OsString</code> menjadi regular <code>String</code>. Ia mengembalikan <code>Result</code>, namun bagian <code>Err</code>nya adalah <code>OsString</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
pub fn into_string(self) -&gt; Result&lt;String, OsString&gt;
<span class="boring">}
</span></code></pre></pre>
<p>Jadi jika ia tidak bekerja, Anda akan kembali mendapatkan <code>OsString</code>. Anda tidak bisa menggunakan <code>.unwrap()</code> karena ia akan panic, tapi Anda bisa menggunakan <code>match</code> untuk kembali mendapatkan <code>OsString</code>. Mari kita coba dengan cara memanggil method yang sama sekali tidak ada.</p>
<pre><pre class="playground"><code class="language-rust">use std::ffi::OsString;

fn main() {
    // ‚ö†Ô∏è
    let os_string = OsString::from(&quot;This string works for your OS too.&quot;);
    match os_string.into_string() {
        Ok(valid) =&gt; valid.thth(),           // Compiler: &quot;Apa ini .thth()??&quot;
        Err(not_valid) =&gt; not_valid.occg(),  // Compiler: &quot;Apa ini .occg()??&quot;
    }
}
</code></pre></pre>
<p>Kemudian compiler memberitahu kita persis apa yang ingin kita ketahui:</p>
<pre><code class="language-text">error[E0599]: no method named `thth` found for struct `std::string::String` in the current scope
 --&gt; src/main.rs:6:28
  |
6 |         Ok(valid) =&gt; valid.thth(),
  |                            ^^^^ method not found in `std::string::String`

error[E0599]: no method named `occg` found for struct `std::ffi::OsString` in the current scope
 --&gt; src/main.rs:7:37
  |
7 |         Err(not_valid) =&gt; not_valid.occg(),
  |                                     ^^^^ method not found in `std::ffi::OsString`
</code></pre>
<p>Kita bisa melihat bahwa type dari <code>valid</code> adalah <code>String</code> dan type dari <code>not_valid</code> adalah <code>OsString</code>.</p>
<h3 id="mem"><a class="header" href="#mem">mem</a></h3>
<p><code>std::mem</code> memiliki method-method yang menarik. Kita sudah melihatnya beberapa, misalnya <code>.size_of()</code>, <code>.size_of_val()</code> dan <code>.drop()</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn main() {
    println!(&quot;{}&quot;, mem::size_of::&lt;i32&gt;());
    let my_array = [8; 50];
    println!(&quot;{}&quot;, mem::size_of_val(&amp;my_array));
    let mut some_string = String::from(&quot;You can drop a String because it's on the heap&quot;);
    mem::drop(some_string);
    // some_string.clear();   jika kita melakukan ini, maka programnya akan panic
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">4
200
</code></pre>
<p>Ini adalah beberapa method lainnya di <code>mem</code>:</p>
<p><code>swap()</code>: dengan method ini, Anda bisa mengubah value diantara dua variabel. Anda perlu menggunakan mutable reference di masing-masing variabel tersebut untuk melakukannya. Ini sangat berguna ketika Anda memiliki dua variabel yang ingin Anda tukar valuenya dan Rust tidak mengizinkannya karena adanya borrowing rules. Atau juga di saat Anda ingin menukar dua variabel dengan cepat.</p>
<p>Berikut adalah contohnya:</p>
<pre><pre class="playground"><code class="language-rust">use std::{mem, fmt};

struct Ring { // Buat sebuah ring dari Lord of the Rings
    owner: String,
    former_owner: String,
    seeker: String, // seeker artinya &quot;orang yang mencari-cari cincin tersebut&quot;
}

impl Ring {
    fn new(owner: &amp;str, former_owner: &amp;str, seeker: &amp;str) -&gt; Self {
        Self {
            owner: owner.to_string(),
            former_owner: former_owner.to_string(),
            seeker: seeker.to_string(),
        }
    }
}

impl fmt::Display for Ring { // Display untuk menampilkan siapa yang memilikinya dan siapa yang menginginkannya
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, &quot;{} has the ring, {} used to have it, and {} wants it&quot;, self.owner, self.former_owner, self.seeker)
        }
}

fn main() {
    let mut one_ring = Ring::new(&quot;Frodo&quot;, &quot;Gollum&quot;, &quot;Sauron&quot;);
    println!(&quot;{}&quot;, one_ring);
    mem::swap(&amp;mut one_ring.owner, &amp;mut one_ring.former_owner); // Gollum mendapatkan cincinnya kembali
    println!(&quot;{}&quot;, one_ring);
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">Frodo has the ring, Gollum used to have it, and Sauron wants it
Gollum has the ring, Frodo used to have it, and Sauron wants it
</code></pre>
<p><code>replace()</code>: mirip seperti swap, dan sebenarnya di dalamnya memang menggunakan swap, seperti yang Anda lihat:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn replace&lt;T&gt;(dest: &amp;mut T, mut src: T) -&gt; T {
    swap(dest, &amp;mut src);
    src
}
<span class="boring">}
</span></code></pre></pre>
<p>Jadi sebenarnya ia hanya melakukan swap dan kemudian mengembalikan item yang lain. Dengan method ini, Anda mengganti value dengan value lain yang Anda masukkan. Dan karena ia mengembalikan value yang terdahulu, jadi Anda harus menggunakan <code>let</code>. Beginilah contohnya.</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

struct City {
    name: String,
}

impl City {
    fn change_name(&amp;mut self, name: &amp;str) {
        let old_name = mem::replace(&amp;mut self.name, name.to_string());
        println!(
            &quot;The city once called {} is now called {}.&quot;,
            old_name, self.name
        );
    }
}

fn main() {
    let mut capital_city = City {
        name: &quot;Constantinople&quot;.to_string(),
    };
    capital_city.change_name(&quot;Istanbul&quot;);
}
</code></pre></pre>
<p>Hasilnya adalah <code>The city once called Constantinople is now called Istanbul.</code>.</p>
<p>Ada juga function yang bernama <code>.take()</code> yang mirip dengan <code>.replace()</code>, tapi ia menyisakan default value pada itemnya. Anda akan mengingat bahwa default value biasanya adalah sesuatu yang bernilai 0, &quot;&quot;, dan lain-lain. Inilah signaturenya:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
pub fn take&lt;T&gt;(dest: &amp;mut T) -&gt; T
where
    T: Default,
<span class="boring">}
</span></code></pre></pre>
<p>Sehingga Anda bisa melakukan hal seperti berikut:</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

fn main() {
    let mut number_vec = vec![8, 7, 0, 2, 49, 9999];
    let mut new_vec = vec![];

    number_vec.iter_mut().for_each(|number| {
        let taker = mem::take(number);
        new_vec.push(taker);
    });

    println!(&quot;{:?}\n{:?}&quot;, number_vec, new_vec);
}
</code></pre></pre>
<p>Dan sebagaimana yang Anda lihat, ia menggantikan semua angka dengan 0: tidak ada index yang dihapus.</p>
<pre><code class="language-text">[0, 0, 0, 0, 0, 0]
[8, 7, 0, 2, 49, 9999]
</code></pre>
<p>Tentu saja, untuk type yang Anda buat, Anda bisa mengimplementasikan <code>Default</code> ke apapun yang Anda inginkan. Mari kita lihat contoh dimana kita memiliki sebuah <code>Bank</code> dan sebuah <code>Robber</code>. Setiap si maling merampok <code>Bank</code>, ia merampok uangnya dari desk. Namun si desk bisa mengambil uang lagi dari brankas kapanpun, sehingga ia selalu memiliki 50. Kita akan membuat type kita sendiri untuk kasus ini, sehingga ia selalu memiliki 50. Beginilah codenya:</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;
use std::ops::{Deref, DerefMut}; // Kita akan menggunakan ini untuk mendapatkan fitur dari u32

struct Bank {
    money_inside: u32,
    money_at_desk: DeskMoney, // Ini adalah type &quot;smart pointer&quot; yang kita buat. Ia memiliki nilai defaultnya sendiri, namun ia juga akan menggunakan u32
}

struct DeskMoney(u32);

impl Default for DeskMoney {
    fn default() -&gt; Self {
        Self(50) // defaultnya selalu bernilai 50, bukan 0
    }
}

impl Deref for DeskMoney { // Dengan ini, kita bisa mengakses u32 menggunakan *
    type Target = u32;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl DerefMut for DeskMoney { // Dan dengan ini, kita bisa menambahkan, mengurangi, dst.
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.0
    }
}

impl Bank {
    fn check_money(&amp;self) {
        println!(
            &quot;There is ${} in the back and ${} at the desk.\n&quot;,
            self.money_inside, *self.money_at_desk // Gunakan * sehingga kita bisa mencetak u32
        );
    }
}

struct Robber {
    money_in_pocket: u32,
}

impl Robber {
    fn check_money(&amp;self) {
        println!(&quot;The robber has ${} right now.\n&quot;, self.money_in_pocket);
    }

    fn rob_bank(&amp;mut self, bank: &amp;mut Bank) {
        let new_money = mem::take(&amp;mut bank.money_at_desk); // Disini, ia akan mengambil uangnya, dan meninggalkan 50 karena itu merupakan nilai defaultnya
        self.money_in_pocket += *new_money; // Gunakan * karena kita hanya bisa menambahkan u32. DeskMoney tidak bisa melakukan pertambahan
        bank.money_inside -= *new_money;    // Disini juga
        println!(&quot;She robbed the bank. She now has ${}!\n&quot;, self.money_in_pocket);
    }
}

fn main() {
    let mut bank_of_klezkavania = Bank { // Buat sebuah bank
        money_inside: 5000,
        money_at_desk: DeskMoney(50),
    };
    bank_of_klezkavania.check_money();

    let mut robber = Robber { // Buat seorang perampok
        money_in_pocket: 50,
    };
    robber.check_money();

    robber.rob_bank(&amp;mut bank_of_klezkavania); // Rampok, kemudian periksa uangnya
    robber.check_money();
    bank_of_klezkavania.check_money();

    robber.rob_bank(&amp;mut bank_of_klezkavania); // Lakukan lagi
    robber.check_money();
    bank_of_klezkavania.check_money();

}
</code></pre></pre>
<p>Hasil cetaknya adalah:</p>
<pre><code class="language-text">There is $5000 in the back and $50 at the desk.

The robber has $50 right now.

She robbed the bank. She now has $100!

The robber has $100 right now.

There is $4950 in the back and $50 at the desk.

She robbed the bank. She now has $150!

The robber has $150 right now.

There is $4900 in the back and $50 at the desk.
</code></pre>
<p>Anda bisa melihat bahwa di desk selalu ada $50.</p>
<h3 id="prelude"><a class="header" href="#prelude">prelude</a></h3>
<p>Standard library juga memiliki prelude. Inilah mengapa Anda tidak perlu menuliskan sesuatu seperti <code>use std::vec::Vec</code> untuk membuat sebuah <code>Vec</code>. Anda bisa melihat semua itemnya <a href="https://doc.rust-lang.org/std/prelude/index.html#prelude-contents">di sini</a>, dan kita sudah mengetahui hampir semuanya:</p>
<ul>
<li><code>std::marker::{Copy, Send, Sized, Sync, Unpin}</code>. Anda belum pernah melihat <code>Unpin</code> sebelumnya, karena ia sudah digunakan hampir di semua type (seperti <code>Sized</code>, yang juga sangat umum). &quot;Pin&quot; berarti tidak membiarkan sesuatu bergerak. Pada kasus ini, <code>Pin</code> berarti bahwa ia tidak bisa berpindah di memory, namun banyak item yang memiliki <code>Unpin</code>, sehingga Anda bisa melakukannya. Inilah mengapa function-function seperti <code>std::mem::replace</code> bekerja, karena mereka tidak dalam kondisi ter-pin.</li>
<li><code>std::ops::{Drop, Fn, FnMut, FnOnce}</code>.</li>
<li><code>std::mem::drop</code></li>
<li><code>std::boxed::Box</code>.</li>
<li><code>std::borrow::ToOwned</code>. Anda sudah melihat ini sedikit di saat mempelajari <code>Cow</code>, yang mana bisa mengambil borrowed value dan membuat kepemilikannya menjadi owned. Ia menggunakan method <code>.to_owned()</code> untuk melakukan. Anda juga bisa menggunakan <code>.to_owned()</code> pada <code>&amp;str</code> untuk mendapatkan <code>String</code>, dan sama pula pada borrowed value lainnya.</li>
<li><code>std::clone::Clone</code></li>
<li><code>std::cmp::{PartialEq, PartialOrd, Eq, Ord}</code>.</li>
<li><code>std::convert::{AsRef, AsMut, Into, From}</code>.</li>
<li><code>std::default::Default</code>.</li>
<li><code>std::iter::{Iterator, Extend, IntoIterator, DoubleEndedIterator, ExactSizeIterator}</code>. Sebelumnya kita menggunakan <code>.rev()</code> untuk iterator: Ini sebenarnya membuat <code>DoubleEndedIterator</code>. <code>ExactSizeIterator</code> hanyalah sesuatu seperti <code>0..10</code>: ia sudah tahu bahwa ia memiliki <code>.len()</code> sebesar 10. Iterator yang lain tidak mengetahui panjangnya secara pasti.</li>
<li><code>std::option::Option::{self, Some, None}</code>.</li>
<li><code>std::result::Result::{self, Ok, Err}</code>.</li>
<li><code>std::string::{String, ToString}</code>.</li>
<li><code>std::vec::Vec</code>.</li>
</ul>
<p>Bagaimana jika Anda tidak menginginkan prelude karena suatu hal tertentu? Cukup tambahkan attribute <code>#![no_implicit_prelude]</code>. Mari kita coba dan kita lihat teguran dari compiler:</p>
<pre><pre class="playground"><code class="language-rust">// ‚ö†Ô∏è
#![no_implicit_prelude]
fn main() {
    let my_vec = vec![8, 9, 10];
    let my_string = String::from(&quot;This won't work&quot;);
    println!(&quot;{:?}, {}&quot;, my_vec, my_string);
}
</code></pre></pre>
<p>Sekarang Rust tidak mengerti apa yang ingin kita lakukan:</p>
<pre><code class="language-text">error: cannot find macro `println` in this scope
 --&gt; src/main.rs:5:5
  |
5 |     println!(&quot;{:?}, {}&quot;, my_vec, my_string);
  |     ^^^^^^^

error: cannot find macro `vec` in this scope
 --&gt; src/main.rs:3:18
  |
3 |     let my_vec = vec![8, 9, 10];
  |                  ^^^

error[E0433]: failed to resolve: use of undeclared type or module `String`
 --&gt; src/main.rs:4:21
  |
4 |     let my_string = String::from(&quot;This won't work&quot;);
  |                     ^^^^^^ use of undeclared type or module `String`

error: aborting due to 3 previous errors
</code></pre>
<p>Jadi untuk code ini, Anda perlu memberitahukan Rust untuk menggunakan crate <code>extern</code> (external) bernama <code>std</code>, dan kemudian menyebutkan item-item yang Anda ingin gunakan. Berikut ini adalah semua yang harus kita lakukan hanya untuk membuat sebuah Vec dan String, dan juga mencetaknya:</p>
<pre><pre class="playground"><code class="language-rust">#![no_implicit_prelude]

extern crate std; // Sekarang Anda perlu memberitahukan kepada Rust bahwa Anda ingin menggunakan crate bernama std
use std::vec; // kita memerlukan macro vec
use std::string::String; // dan juga string
use std::convert::From; // dan ini berguna untuk mengkonversi dari &amp;str ke String
use std::println; // dan ini untuk print

fn main() {
    let my_vec = vec![8, 9, 10];
    let my_string = String::from(&quot;This won't work&quot;);
    println!(&quot;{:?}, {}&quot;, my_vec, my_string);
}
</code></pre></pre>
<p>Dan sekarang codenya berjalan. Hasilnya adalah  <code>[8, 9, 10], This won't work</code>. Jadinya, Anda bisa melihat mengapa Rust menggunakan prelude. Namun jika Anda ingin, Anda tidak perlu menggunakannya. Dan bahkan Anda bisa menggunakan <code>#![no_std]</code> (kita pernah melihatnya sekali sebelumnya) ketika Anda bahkan tidak bisa menggunakan sesuatu seperti stack memory. Tetapi seringnya kita tidak perlu berpikir tentang tidak menggunakan prelude atau <code>std</code> sama sekali.</p>
<p>Jadi mengapa sebelumnya kita belum pernah melihat keyword <code>extern</code>? Ini karena kita tidak terlalu memerlukannya lagi. Di Rust versi lama, di saat kita memanggil external crate, kita harus menggunakannya. Jadi, di Rust versi lama, untuk menggunakan <code>rand</code>, Anda perlu menuliskan:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate rand;
<span class="boring">}
</span></code></pre></pre>
<p>dan kemudian statement <code>use</code> untuk mod, trait, dll. yang ingin Anda gunakan. Namun compiler Rust sekarang tidak membutuhkan bantuan ini lagi - Anda cukup menggunakan <code>use</code> dan compiler tahu dimana menemukannya. Jadi Anda hampir tidak pernah membutuhkan <code>extern crate</code> lagi. Tapi di code Rust yang ditulis oleh orang lain, mungkin Anda masih melihatnya di bagian atas codenya.</p>
<h3 id="time"><a class="header" href="#time">time</a></h3>
<p><code>std::time</code> adalah dimana Anda bisa mendapatkan function untuk waktu. (Jika Anda menginginkan lebih banyak function, crate seperti <code>chrono</code> bisa digunakan.) Function paling sederhana adalah mengambil system time dengan <code>Instant::now()</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time = Instant::now();
    println!(&quot;{:?}&quot;, time);
}
</code></pre></pre>
<p>Jika Anda mencetaknya, Anda akan mendapatkan sesuatu seperti berikut: <code>Instant { tv_sec: 2738771, tv_nsec: 685628140 }</code>. Itu adalah detik dan nanosecond, namun itu tidaklah terlalu berguna. Misalnya, jika Anda melihat pada 2738771 detik (dicetak pada bulan Agustus), itu adalah 31.70 hari. Itu sama sekali tidak ada hubungannya dengan bulan atau hari dalam setahun. Namun laman tentang <code>Instant</code> memberi tahu kita bahwa <code>Instant</code> tidaklah berguna jika dipakai begitu saja. Dikatakan bahwa &quot;opaque and useful only with Duration.&quot; Opaque berarti &quot;Anda tidak bisa memahaminya&quot;, dan duration/durasi artinya &quot;berapa lama waktu sudah berlalu&quot;. Sehingga ia hanya berguna di saat kita perlu melakukan sesuatu seperti membandingkan waktu.</p>
<p>Jika Anda melihat pada trait-trait yang berada di sebelah kiri, salah satu dari trait tersebut adalah <code>Sub&lt;Instant&gt;</code>. Yang berarti kita bisa menggunakan <code>-</code> untuk mengurangkannya dengan yang lain. Dan saat kita klik pada [src] untuk melihat apa yang ia lakukan, maka kita akan melihat code berikut:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Sub&lt;Instant&gt; for Instant {
    type Output = Duration;

    fn sub(self, other: Instant) -&gt; Duration {
        self.duration_since(other)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Jadinya, ia mengambil <code>Instant</code> dan menggunakan method <code>.duration_since()</code> untuk mendapatkan <code>Duration</code>. Mari kita coba untuk mencetaknya. Kita akan membuat dua buah <code>Instant::now()</code> tepat setelah satu sama lain (time2 ditulis setelah time1), kemudian kita akan membuat programnya sibuk untuk sementara waktu. Kemudian kita akan membuat satu lagi <code>Instant::now()</code>. Akhirnya kita akan melihat berapa lama waktu yang dibutuhkan.</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time1 = Instant::now();
    let time2 = Instant::now(); // time2 dibuat tepat setelah dibuatnya time1

    let mut new_string = String::new();
    loop {
        new_string.push('·É¨'); // buat Rust melakukan push karakter Georgian ini ke dalam String
        if new_string.len() &gt; 100_000 { //  lakukan sampai panjangnya 100,000 byte
            break;
        }
    }
    let time3 = Instant::now();
    println!(&quot;{:?}&quot;, time2 - time1);
    println!(&quot;{:?}&quot;, time3 - time1);
}
</code></pre></pre>
<p>Hasilnya adalah seperti berikut:</p>
<pre><code class="language-text">1.025¬µs
683.378¬µs
</code></pre>
<p>Jadi ada jeda 1 microsecond vs. 683 microsecond. Kita bisa lihat bahwa Rust memerlukan waktu untuk melakukannya.</p>
<p>Ada satu hal menarik yang bisa kita lakukan dengan sebuah <code>Instant</code>. Kita bisa mengubahnya menjadi <code>String</code> dengan menggunakan <code>format!(&quot;{:?}&quot;, Instant::now());</code>. Begini codenya:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn main() {
    let time1 = format!(&quot;{:?}&quot;, Instant::now());
    println!(&quot;{}&quot;, time1);
}
</code></pre></pre>
<p>Hasil cetaknya adalah seperti ini: <code>Instant { tv_sec: 2740773, tv_nsec: 632821036 }</code>. Tentu saja itu tidak bergunak, namun jika kita menggunakan <code>.iter()</code> dan <code>.rev()</code> dan <code>.skip(2)</code>, kita bisa membuang <code>}</code> dan <code> </code>. Kita bisa menggunakannya untuk membuat sebuah random number generator.</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Instant;

fn bad_random_number(digits: usize) {
    if digits &gt; 9 {
        panic!(&quot;Random number can only be up to 9 digits&quot;);
    }
    let now = Instant::now();
    let output = format!(&quot;{:?}&quot;, now);

    output
        .chars()
        .rev()
        .skip(2)
        .take(digits)
        .for_each(|character| print!(&quot;{}&quot;, character));
    println!();
}

fn main() {
    bad_random_number(1);
    bad_random_number(1);
    bad_random_number(3);
    bad_random_number(3);
}
</code></pre></pre>
<p>Hasilnya adalah seperti berikut:</p>
<pre><code class="language-text">6
4
967
180
</code></pre>
<p>Functionnya kita beri nama <code>bad_random_number</code> karena itu bukanlah cara yang bagus untuk membuat random number generator. Rust memiliki crates yang lebih baik untuk membuat angka random dengan code yang lebih singkat dari <code>rand</code> contohnya <code>fastrand</code>. Namun ini adalah contoh yang baik tentang bagaimana kita bisa menggunakan imajinasi kita membuat sesuatu dengan menggunakan <code>Instant</code>.</p>
<p>Jika Anda memiliki thread, Anda bisa menggunakan <code>std::thread::sleep</code> untuk membuatnya stop untuk sementara waktu. Di saat Anda melakukan ini, Anda perlu memberikannya durasi. Anda tidak perlu membuat membuat lebih dari satu thread untuk melakukan ini karena sebenarnya setiap program berjalan dengan menggunakan setidaknya satu thread. <code>sleep</code> memerlukan <code>Duration</code>, sehingga ia bisa mengetahui seberapa lama ia sleep. Anda bisa memilih unitnya (satuannya) seperti ini: <code>Duration::from_millis()</code>, <code>Duration::from_secs</code>, dll. Seperti inilah contohnya:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Duration;
use std::thread::sleep;

fn main() {
    let three_seconds = Duration::from_secs(3);
    println!(&quot;I must sleep now.&quot;);
    sleep(three_seconds);
    println!(&quot;Did I miss anything?&quot;);
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">I must sleep now.
Did I miss anything?
</code></pre>
<p>namun thread tidak melakukan apapun selama tiga detik. Anda biasanya menggunakan <code>.sleep()</code> di saat Anda menggunakan banyak thread yang perlu mencoba melakukan banyak hal, misalnya memeriksa koneksi. Anda tidak menginginkan thread menggunakan processor Anda untuk mencoba 100,000 kali dalam sedetik ketika Anda hanya ingin memeriksanya sewaktu-waktu. Jadi, Anda dapat menyetel <code>Duration</code>, dan ia akan mencoba melakukan tugasnya setiap kali threadnya mulai aktif.</p>
<h3 id="other-macros"><a class="header" href="#other-macros">Other macros</a></h3>
<p>Mari kita melihat-lihat beberapa macro yang lain.</p>
<p><code>unreachable!()</code></p>
<p>Macro ini mirip seperti <code>todo!()</code>, namun untuk code yang tidak pernah Anda tuliskan. Mungkin Anda memiliki <code>match</code> di dalam enum yang Anda sendiri tahu bahwa kondisinya tidak akan memilih salah satu arm pun, jadi codenya sama sekali tidak pernha bisa dijangkau (reached). Jika demikian, Anda bisa menuliskan <code>unreachable!()</code> sehingga compiler tahu bagian itu diabaikan saja.</p>
<p>Sebagai contoh, anggap saja Anda memiliki program yang menuliskan sesuatu di saat Anda memilih tempat tinggal. Lokasinya ada di Ukraina, dan semua kota-kotanya baik-baik saja kecuali Chernobyl. Program yang Anda buat tidak akan mengizinkan siapapun memilih Chernobyl, karena kota itu bukanlah tempat yang layak untuk ditinggali untuk sekarang ini. Tapi, enumnya sudah lama dibuat oleh orang lain, dan kita tidak bisa mengubahnya. Jadi di arm yang ada pada <code>match</code>, Anda bisa menggunakan macro <code>unreachable!()</code> disini. Codenya terlihat seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">enum UkrainePlaces {
    Kiev,
    Kharkiv,
    Chernobyl, // Anggap saja kita tidak bisa mengubah enumnya - Chernobyl akan selalu ada di dalam enum ini
    Odesa,
    Dnipro,
}

fn choose_city(place: &amp;UkrainePlaces) {
    use UkrainePlaces::*;
    match place {
        Kiev =&gt; println!(&quot;You will live in Kiev&quot;),
        Kharkiv =&gt; println!(&quot;You will live in Kharkiv&quot;),
        Chernobyl =&gt; unreachable!(),
        Odesa =&gt; println!(&quot;You will live in Odesa&quot;),
        Dnipro =&gt; println!(&quot;You will live in Dnipro&quot;),
    }
}

fn main() {
    let user_input = UkrainePlaces::Kiev; // Anggap saja inputan dari user dibuat dari suatu function. User tidak akan bisa memilih Chernobyl, apapun yang terjadi
    choose_city(&amp;user_input);
}
</code></pre></pre>
<p>Hasilnya adalah <code>You will live in Kiev</code>.</p>
<p><code>unreachable!()</code> juga baik digunakan untuk membaca code karena ia akan mengingatkan Anda bahwa ada beberapa bagian dari code yang kondisinya tidak bisa dijangkau (unreachable). Anda harus pastikan bahwa code tersebut memang benar tidak bisa dijangkau. Karena jika Anda menggunakan <code>unreachable!()</code>, padahal armnya bisa dijangkau, maka programnya akan panic.</p>
<p>Juga, jika Anda memiliki code yang unreachable, maka compiler akan mengetahuinya, dan memberitahukannya ke Anda. Seperti ini contohnya:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let true_or_false = true;

    match true_or_false {
        true =&gt; println!(&quot;It's true&quot;),
        false =&gt; println!(&quot;It's false&quot;),
        true =&gt; println!(&quot;It's true&quot;), // Oops, kita menuliskan true lagi disini
    }
}
</code></pre></pre>
<p>Compiler akan mengatakan:</p>
<pre><code class="language-text">warning: unreachable pattern
 --&gt; src/main.rs:7:9
  |
7 |         true =&gt; println!(&quot;It's true&quot;),
  |         ^^^^
  |
</code></pre>
<p>Sedangkan <code>unreachable!()</code> ini diperuntukkan di saat compiler tidak mengetahuinya, seperti contoh kita yang di awal tersebut (tentang Chernobyl).</p>
<p><code>column!</code>, <code>line!</code>, <code>file!</code>, <code>module_path!</code></p>
<p>Empat macro ini mirip seperti <code>dbg!()</code> karena Anda memasukannya ke code Anda untuk memberikan informasi mengenai debug. Namun ia tidak mengambil variabel apapun - Anda cukup menggunakan mereka dengan bracket (tanda kurung) dan tidak ada yang lain. Keempatnya mudah untuk dipelajari:</p>
<ul>
<li><code>column!()</code> memberikan Anda informasi kolom dimana Anda menuliskannya,</li>
<li><code>file!()</code> memberikan Anda informasi nama file dimana Anda menuliskannya,</li>
<li><code>line!()</code> memberikan Anda informasi line/baris dimana Anda menuliskannya, dan</li>
<li><code>module_path!()</code> memberikan Anda informasi di module mana ia berada.</li>
</ul>
<p>Code berikut ini menunjukkan keempatnya dalam contoh yang sederhana. Kita akan menganggap ada lebih banyak code (mod di dalam mod), karena itulah alasannya kita ingin menggunakan macro <code>module_path!()</code>. Anda bisa membayangkan sebuah program Rust yang besar yang dibuat dengan banyak mod dan file.</p>
<pre><pre class="playground"><code class="language-rust">pub mod something {
    pub mod third_mod {
        pub fn print_a_country(input: &amp;mut Vec&lt;&amp;str&gt;) {
            println!(
                &quot;The last country is {} inside the module {}&quot;,
                input.pop().unwrap(),
                module_path!()
            );
        }
    }
}

fn main() {
    use something::third_mod::*;
    let mut country_vec = vec![&quot;Portugal&quot;, &quot;Czechia&quot;, &quot;Finland&quot;];
    
    // lakukan sesuatu
    println!(&quot;Hello from file {}&quot;, file!());

    // lakukan sesuatu
    println!(
        &quot;On line {} we got the country {}&quot;,
        line!(),
        country_vec.pop().unwrap()
    );

    // lakukan sesuatu

    println!(
        &quot;The next country is {} on line {} and column {}.&quot;,
        country_vec.pop().unwrap(),
        line!(),
        column!(),
    );

    // ada banyak code di bagian ini

    print_a_country(&amp;mut country_vec);
}
</code></pre></pre>
<p>Hasil cetaknya adalah:</p>
<pre><code class="language-text">Hello from file src/main.rs
On line 23 we got the country Finland
The next country is Czechia on line 32 and column 9.
The last country is Portugal inside the module rust_book::something::third_mod
</code></pre>
<p><code>cfg!</code></p>
<p>Kita mengetahui bahwa kita bisa menggunakan attribute seperti <code>#[cfg(test)]</code> dan <code>#[cfg(windows)]</code> untuk memberitahukan compiler apa yang harus dilakukan dalam kasus tertentu. Di saat Anda memiliki <code>test</code>, ia akan menjalankan code ketika kita menjalankan Rust dalam mode testing (jika ia ada di dalam komputer Anda, maka Anda perlu mengetikkan <code>cargo test</code>). Dan di saat Anda menggunakan <code>windows</code>, ia akan menjalankan code jika user menggunakan Windows. Tapi mungkin Anda hanya ingin mengubah sedikit code tergantung pada operating systemnya, dll. Di saat seperti itulah macro ini menjadi berguna. ia akan me-return <code>bool</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let helpful_message = if cfg!(target_os = &quot;windows&quot;) { &quot;backslash&quot; } else { &quot;slash&quot; };

    println!(
        &quot;...then in your hard drive, type the directory name followed by a {}. Then you...&quot;,
        helpful_message
    );
}
</code></pre></pre>
<p>Hasil cetaknya akan berbeda, berdasarkan operating system yang Anda gunakan. Rust Playground berjalan di atas Linux, sehingga ia akan mencetak:</p>
<pre><code class="language-text">...then in your hard drive, type the directory name followed by a slash. Then you...
</code></pre>
<p><code>cfg!()</code> berfungsi untuk setiap jenis konfigurasi. Berikut adalah contoh dari sebuah function yang berjalan dengan cara yang berbeda saat Anda menjalankannya di dalam test.</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)] // cfg! akan bisa mencari kata test
mod testing {
    use super::*;
    #[test]
    fn check_if_five() {
        assert_eq!(bring_number(true), 5); // Function bring_number() ini semestinya me-return 5
    }
}

fn bring_number(should_run: bool) -&gt; u32 { // Function ini memerlukan bool untuk mengetahui apakah ia harus dijalankan
    if cfg!(test) &amp;&amp; should_run { // jika ia semestinya dijalankan dan memiliki konfigurasi test, maka akan me-return 5
        5
    } else if should_run { // if ia bukan test namun ia harus dijalankan, maka cetak sesuatu. Jika Anda menjalankan test. ia akan mengabaikan statement println!
        println!(&quot;Returning 5. This is not a test&quot;);
        5
    } else {
        println!(&quot;This shouldn't run, returning 0.&quot;); // sebaliknya, return 0
        0
    }
}

fn main() {
    bring_number(true);
    bring_number(false);
}
</code></pre></pre>
<p>Sekarang ia akan berjalan secara berbeda, tergantung dari konfigurasinya. Jika Anda hanya menjalankan programnya, hasil cetaknya adalah seperti ini:</p>
<pre><code class="language-text">Returning 5. This is not a test
This shouldn't run, returning 0.
</code></pre>
<p>Namun jika Anda menjalankannya di dalam test mode (<code>cargo test</code> untuk Rust yang ada pada komputer), maka ia akan menjalankan testnya. Dan karena di kasus ini testnya selalu me-return 5, testnya akan pass.</p>
<pre><code class="language-text">running 1 test
test testing::check_if_five ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Chapter_60.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="Chapter_62.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Chapter_60.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="Chapter_62.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
