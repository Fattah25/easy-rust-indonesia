<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> Arc - Easy Rust</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong> Updates</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong> Who am I?</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong> Catatan dari translator</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong> Writing Rust in Easy English</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong> Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong> üöß and ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong> Comments</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong> Types</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong> Type inference</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong> Printing 'hello, world!'</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong> Display and debug</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong> Mutability (changing)</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong> The stack, the heap, and pointers</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong> More about printing</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong> Strings</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong> const and static</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong> More on references</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong> Mutable references</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong> Giving references to functions</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong> Copy types</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong> Collection types</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong> Control flow</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong> Structs</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong> Enums</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong> Loops</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong> Implementing structs and enums</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong> Destructuring</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong> References and the dot operator</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong> Generics</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong> Option and Result</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong> Other collections</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong> The ? operator</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong> Traits</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong> Chaining methods</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong> Closures</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong> The dbg! macro and .inspect</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong> Types of &amp;str</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong> Cow</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong> The todo! macro</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong> Rc</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong> Multiple threads</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong> Closures in functions</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_50.html" class="active"><strong aria-hidden="true">51.</strong> Arc</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong> Channels</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong> Reading Rust documentation</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong> Box</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong> Box around traits</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong> Default and the builder pattern</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong> Deref and DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong> Crates and modules</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong> Testing</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong> External crates</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong> A tour of the standard library</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong> Writing macros</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong> cargo</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong> Taking user input</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong> Using files</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="Chapter_67.html"><strong aria-hidden="true">68.</strong> The end?</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Easy Rust</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="arc"><a class="header" href="#arc">Arc</a></h2>
<p>Anda ingat bahwa kita menggunakan <code>Rc</code> untuk memberi variabel lebih dari owner. Jika kita melakukan hal yang sama di dalam thread, kita memerlukan <code>Arc</code>. <code>Arc</code> singkatan dari &quot;atomic reference counter&quot;. Atomic berarti bahwa ia menggunakan prosesor di komputer sehingga datanya hanya ditulis sekali setiap waktu. Ini penting karena jika dua thread menulis data pada waktu yang sama, Anda akan mendapatkan hasil yang salah. Contohnya, bayangkan jika Anda bisa melakukan ini di Rust :</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let mut x = 10;

for i in 0..10 { // Thread 1
    x += 1
}
for i in 0..10 { // Thread 2
    x += 1
}
<span class="boring">}
</span></code></pre></pre>
<p>Jika Thread 1 dan Thread 2 berjalan bersamaan, mungkin hal seperti ini akan terjadi:</p>
<ul>
<li>Thread 1 melihat 10, maka ia menuliskan 11. Kemudian Thread 2 melihat 11, maka ia menulis 12. Tidak ada masalah sejauh ini.</li>
<li>Thread 1 melihat 12. Pada waktu yang sama, Thread 2 melihat 12. Thread 1 menulis 13. Dan Thread 2 menulis 13. Sekarang kita memili 13, padahal seharusnya adalah 14. Ini adalah masalah yang cukup berbahaya.</li>
</ul>
<p><code>Arc</code> menggunakan prosesor untuk memastikan hal seperti ini tidak terjadi, jadi ini adlaah cara yang harus Anda gunakan di saat Anda menggunakan banyak thread. Anda tidak perlu memakai <code>Arc</code> jika hanya menggunakan satu thread saja, karena <code>Rc</code> sedikit lebih cepat dibandingkan dengan <code>Arc</code>.</p>
<p>Anda tidak bisa mengubah datanya hanya dengan menggunakan <code>Arc</code>. jadi Anda harus membungkus datanya menggunakan <code>Mutex</code>, dan membungkus <code>Mutex</code> dengan <code>Arc</code>.</p>
<p>Mari kita gunakan <code>Mutex</code> di dalam <code>Arc</code> untuk mengubah nilai dari sebuah angka. Pertama-tama, kita gunakn satu thread:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let handle = std::thread::spawn(|| {
        println!(&quot;The thread is working!&quot;) // melakukan test terhadap thread
    });

    handle.join().unwrap(); // Buat threadnya menunggu sampai semuanya selesai
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>Sejauh ini, ia akan mencetak:</p>
<pre><code class="language-text">The thread is working!
Exiting the program
</code></pre>
<p>Bagus. Sekarang kita masukkan loop <code>for</code> dengan iterasi <code>0..5</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let handle = std::thread::spawn(|| {
        for _ in 0..5 {
            println!(&quot;The thread is working!&quot;)
        }
    });

    handle.join().unwrap();
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>Sejauh ini programnya masih bekerja. Ini adalah hasilnya:</p>
<pre><code class="language-text">The thread is working!
The thread is working!
The thread is working!
The thread is working!
The thread is working!
Exiting the program
</code></pre>
<p>Sekarang, kita buat satu thread lagi. Setiap thread Akan melakukan hal yang sama. Anda bisa melihat bahwa thread bekerja pada waktu yang bersamaan. Terkadang ia akan mengatakan <code>Thread 1 is working!</code> terlebih dahulu, namun dilain waktu, <code>Thread 2 is working!</code> yang akan dimunculkan terlebih dahulu. Inilah yang dinamakan sebagai <strong>concurrency</strong>, yang artinya &quot;running together&quot;/&quot;dijalankan bersama-sama&quot;.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

    let thread1 = std::thread::spawn(|| {
        for _ in 0..5 {
            println!(&quot;Thread 1 is working!&quot;)
        }
    });

    let thread2 = std::thread::spawn(|| {
        for _ in 0..5 {
            println!(&quot;Thread 2 is working!&quot;)
        }
    });

    thread1.join().unwrap();
    thread2.join().unwrap();
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 1 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Thread 2 is working!
Exiting the program
</code></pre>
<p>Sekarang kita ingin mengubah nilai dari <code>my_number</code>. Typenya adalah <code>i32</code>. Kita akan menggunakan <code>Arc&lt;Mutex&lt;i32&gt;&gt;</code>: sebuah type <code>i32</code> yang bisa diubah, dan diproteksi menggunakan <code>Arc</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let my_number = Arc::new(Mutex::new(0));
<span class="boring">}
</span></code></pre></pre>
<p>Sekarang setelah kita memiliki <code>my_number</code>, kita bisa melakukan clone. Setiap clone bisa menuju ke thread yang berbeda. Kita memiliki dua threads, jadinya kita akan membuat dua clone:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
let my_number = Arc::new(Mutex::new(0));

let my_number1 = Arc::clone(&amp;my_number); // Clone yang ini akan menuju ke Thread 1
let my_number2 = Arc::clone(&amp;my_number); // Clone yang ini akan menuju ke Thread 2
<span class="boring">}
</span></code></pre></pre>
<p>Sekarang kita memiliki safe clone yang melekat ke <code>my_number</code>, kita bisa melakukan <code>move</code> (memindahkannya) ke dalam thread yang lain threads tanpa ada masalah apapun.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};

fn main() {
    let my_number = Arc::new(Mutex::new(0));

    let my_number1 = Arc::clone(&amp;my_number);
    let my_number2 = Arc::clone(&amp;my_number);

    let thread1 = std::thread::spawn(move || { // Hanya clone yang akan dimasukkan ke Thread 1
        for _ in 0..10 {
            *my_number1.lock().unwrap() +=1; // kunci Mutexnya, ubah nilainya
        }
    });

    let thread2 = std::thread::spawn(move || { // Hanya clone yang akan dimasukkan ke Thread 2
        for _ in 0..10 {
            *my_number2.lock().unwrap() += 1;
        }
    });

    thread1.join().unwrap();
    thread2.join().unwrap();
    println!(&quot;Value is: {:?}&quot;, my_number);
    println!(&quot;Exiting the program&quot;);
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">Value is: Mutex { data: 20 }
Exiting the program
</code></pre>
<p>Dan, berhasil! :D</p>
<p>Kita bisa menggabungkan dua thread ke dalam sebuah loop <code>for</code>, dan membuat codenya menjadi lebih singkat.</p>
<p>Kita perlu untuk menyimpan handle (bertype <code>JoinHandles</code>) sehingga kita bisa menggunakan <code>.join()</code> untuk setiap handle yang berada di luar loop. Jika kita melakukan ini di dalam loop, ia akan menunggu thread pertama selesai sebelum menjalankan thread yang kedua.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};

fn main() {
    let my_number = Arc::new(Mutex::new(0));
    let mut handle_vec = vec![]; // JoinHandles akan dimasukkan ke sini

    for _ in 0..2 { // lakukan dua kali
        let my_number_clone = Arc::clone(&amp;my_number); // Buat clone sebelum memulai thread
        let handle = std::thread::spawn(move || { // Gunakan clonenya disini
            for _ in 0..10 {
                *my_number_clone.lock().unwrap() += 1;
            }
        });
        handle_vec.push(handle); // simpan handle, sehingga kita bisa menggunakan join pada handle di luar loop
                                 // jika kita tidak push handle ke dalam vec, ia akan hangus di sini
    }

    handle_vec.into_iter().for_each(|handle| handle.join().unwrap()); // gunakan method join untuk setiap handles
    println!(&quot;{:?}&quot;, my_number);
}
</code></pre></pre>
<p>Dan hasil akhirnya adalah <code>Mutex { data: 20 }</code>.</p>
<p>Mungkin <code>Arc&lt;Mutex&lt;SomeType&gt;&gt;&gt;</code> terlihat rumit di Rust, namun ia sangat sering digunakan di Rust, so it becomes natural. Selain itu, Anda selalu dapat menulis code Anda menjadi lebih rapi. Ini adalah code yang menggunakan lebih dari satu statement <code>use</code> dan dua buah function. Functionnya tidak melakukan sesuatu yang baru. Ia hanya memindahkan beberapa bagian code keluar dari <code>main()</code>. Anda bisa menuliskan ulang codenya seperti berikut ini apabila Anda merasa code sebelumnya sulit untuk dibaca.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread::spawn; // sehingga kita cukup menuliskan spawn

fn make_arc(number: i32) -&gt; Arc&lt;Mutex&lt;i32&gt;&gt; { // Function yang berguna untuk membuat Mutex di dalam Arc
    Arc::new(Mutex::new(number))
}

fn new_clone(input: &amp;Arc&lt;Mutex&lt;i32&gt;&gt;) -&gt; Arc&lt;Mutex&lt;i32&gt;&gt; { // Function untuk membuat arc clone
    Arc::clone(&amp;input)
}

// Sekarang main() menjadi lebih mudah untuk dibaca
fn main() {
    let mut handle_vec = vec![]; // setiap handle akan masuk ke sini
    let my_number = make_arc(0);

    for _ in 0..2 {
        let my_number_clone = new_clone(&amp;my_number);
        let handle = spawn(move || {
            for _ in 0..10 {
                let mut value_inside = my_number_clone.lock().unwrap();
                *value_inside += 1;
            }
        });
        handle_vec.push(handle);    // handle selesai, sehingga dimasukkan ke dalam vector
    }

    handle_vec.into_iter().for_each(|handle| handle.join().unwrap()); // buat setiap handle menunggu

    println!(&quot;{:?}&quot;, my_number);
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="Chapter_49.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="Chapter_51.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="Chapter_49.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="Chapter_51.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
