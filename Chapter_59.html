<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> Testing - Easy Rust</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong> Update</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong> Who am I?</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong> Catatan dari translator</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong> Writing Rust in Easy English</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong> Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong> üöß and ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong> Comments</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong> Types</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong> Type inference</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong> Printing 'hello, world!'</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong> Display and debug</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong> Mutability (changing)</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong> The stack, the heap, and pointers</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong> More about printing</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong> Strings</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong> const and static</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong> More on references</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong> Mutable references</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong> Giving references to functions</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong> Copy types</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong> Collection types</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong> Control flow</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong> Structs</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong> Enums</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong> Loops</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong> Implementing structs and enums</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong> Destructuring</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong> References and the dot operator</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong> Generics</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong> Option and Result</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong> Other collections</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong> The ? operator</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong> Traits</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong> Chaining methods</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong> Closures</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong> The dbg! macro and .inspect</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong> Types of &amp;str</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong> Cow</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong> The todo! macro</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong> Rc</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong> Multiple threads</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong> Closures in functions</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong> Arc</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong> Channels</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong> Reading Rust documentation</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong> Box</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong> Box around traits</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong> Default and the builder pattern</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong> Deref and DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong> Crates and modules</a></li><li class="chapter-item expanded "><a href="Chapter_59.html" class="active"><strong aria-hidden="true">60.</strong> Testing</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong> External crates</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong> A tour of the standard library</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong> Writing macros</a></li><li class="chapter-item expanded "><a href="Chapter_63.html"><strong aria-hidden="true">64.</strong> cargo</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong> Taking user input</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong> Using files</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="Chapter_67.html"><strong aria-hidden="true">68.</strong> The end?</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Easy Rust</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Testing materi yang baik untuk dipelajari sekarang setelah memahami tentang module. Melakukan test pada code Anda sangatlah mudah di Rust, karena Anda bisa menuliskan testnya tepat setelah penulisan codenya.</p>
<p>Cara termudah untuk menuliskan test adalah menambahkan <code>#[test]</code> di atas functionnya. Seperti inilah contohnya:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn two_is_two() {
    assert_eq!(2, 2);
}
<span class="boring">}
</span></code></pre></pre>
<p>Tapi jika Anda mencoba menjalankannya di Playground, ia akan memberikan error: <code>error[E0601]: `main` function not found in crate `playground</code>. Itu dikarenakan Anda tidak bisa menggunakan <em>Run</em> untuk menjalankan testnya, semestinya Anda menggunakan <em>Test</em>. Dan juga, Anda tidak menggunakan function <code>main()</code> untuk testnya - testnya ditulis di luar <code>main()</code>. Untuk menjalankan ini di Playground, klik pada <code>¬∑¬∑¬∑</code> disebelah <em>RUN</em> dan ubah ke <em>Test</em>. Sekarang jika Anda mengkliknya, maka testnya akan dijalankan. (Jika Anda sudah menginstall Rust, Anda bisa menggunakan <code>cargo test</code> untuk melakukan ini)</p>
<p>Inilah outputnya:</p>
<pre><code class="language-text">running 1 test
test two_is_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Mari kita ubah <code>assert_eq!(2, 2)</code> menjadi <code>assert_eq!(2, 3)</code> dan kita lihat apa yang akan kita dapatkan. Jika testnya gagal, Anda akan mendapatkan informasi:</p>
<pre><code class="language-text">running 1 test
test two_is_two ... FAILED

failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><code>assert_eq!(left, right)</code> adalah cara yang paling umum digunakan untuk melakukan test pada sebuah function di Rust. Jika ia tidak bekerja, ia akan menunjukkanvalue yang berbeda: left (kiri) bernilai 2, tapi right (kanan) bernilai 3.</p>
<p>Apa yang dimaksud dengan <code>RUST_BACKTRACE=1</code>? Ini adalah sebuah setting pada komputer untuk memberikan lebih banyak informasi tentang error tersebut. Playground juga memiliki fitur itu: klik pada <code>¬∑¬∑¬∑</code> di sebelah <code>STABLE</code> dan set <code>Backtrace</code>nya menjadi <code>ENABLED</code>. Jika Anda melakukan itu, ia akan memberikanmu <em>sangat banyak</em> informasi:</p>
<pre><code class="language-text">running 1 test
test two_is_two ... FAILED

failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: 2 == 3', src/lib.rs:3:5
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/libunwind.rs:86
   1: backtrace::backtrace::trace_unsynchronized
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.46/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:78
   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt
             at src/libstd/sys_common/backtrace.rs:59
   4: core::fmt::write
             at src/libcore/fmt/mod.rs:1076
   5: std::io::Write::write_fmt
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/io/mod.rs:1537
   6: std::io::impls::&lt;impl std::io::Write for alloc::boxed::Box&lt;W&gt;&gt;::write_fmt
             at src/libstd/io/impls.rs:176
   7: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:62
   8: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:49
   9: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:198
  10: std::panicking::default_hook
             at src/libstd/panicking.rs:215
  11: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:486
  12: std::panicking::begin_panic
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:410
  13: playground::two_is_two
             at src/lib.rs:3
  14: playground::two_is_two::{{closure}}
             at src/lib.rs:2
  15: core::ops::function::FnOnce::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libcore/ops/function.rs:232
  16: &lt;alloc::boxed::Box&lt;F&gt; as core::ops::function::FnOnce&lt;A&gt;&gt;::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/liballoc/boxed.rs:1076
  17: &lt;std::panic::AssertUnwindSafe&lt;F&gt; as core::ops::function::FnOnce&lt;()&gt;&gt;::call_once
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:318
  18: std::panicking::try::do_call
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:297
  19: std::panicking::try
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panicking.rs:274
  20: std::panic::catch_unwind
             at /rustc/c367798cfd3817ca6ae908ce675d1d99242af148/src/libstd/panic.rs:394
  21: test::run_test_in_process
             at src/libtest/lib.rs:541
  22: test::run_test::run_test_inner::{{closure}}
             at src/libtest/lib.rs:450
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Anda tidak perlu menggunakan backtrace kecuali Anda benar-benar tidak menemukan dimana problemnya berasal. Tapi sebenarnya Anda tidak perlu untuk memahami semua yang tertulis di situ. Jika Anda tetap membaca hasil backtrace tersebut, Anda nantinya akan melihat line 13 dimana ia mengatakan <code>playground</code> - itu adalah bagian dimana backtrace berbicara tentang code kita. Sedangkan yang lainnya itu adalah tentang apa yang Rust lakukan pada library yang lain untuk menjalankan program kita. Namun dua line ini menunjukkan Anda bahwa ia melihat pada baris 2 dan baris 3 yang ada di playground, yang mana adalah petunjuk untuk memeriksa apakah ada kesalahan disana. Inilah bagian dari backtrace tersebut:</p>
<pre><code class="language-text">  13: playground::two_is_two
             at src/lib.rs:3
  14: playground::two_is_two::{{closure}}
             at src/lib.rs:2
</code></pre>
<p>Edit: Rust memutakhirkan backtrace messagenya di awal 2021 untuk hanya menampilkan information yang paling penting. Dan sekarang ia jadi lebih mudah untuk dibaca:</p>
<pre><code class="language-text">failures:

---- two_is_two stdout ----
thread 'two_is_two' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `3`', src/lib.rs:3:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:493:5
   1: core::panicking::panic_fmt
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/panicking.rs:92:14
   2: playground::two_is_two
             at ./src/lib.rs:3:5
   3: playground::two_is_two::{{closure}}
             at ./src/lib.rs:2:1
   4: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
   5: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    two_is_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.02s
</code></pre>
<p>Sekarang kita ubah lagi backtracenya menjadi dan kembali ke test yang biasanya. Sekarang kita akan menuliskan function lainnya, dan menggunakan function test untuk mengetestnya. Berikut adalah contohnya:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_two() -&gt; i8 {
    2
}
#[test]
fn it_returns_two() {
    assert_eq!(return_two(), 2);
}

fn return_six() -&gt; i8 {
    4 + return_two()
}
#[test]
fn it_returns_six() {
    assert_eq!(return_six(), 6)
}
<span class="boring">}
</span></code></pre></pre>
<p>Dan ini adalah hasil dari menjalankan kedua function test tersebut:</p>
<pre><code class="language-text">running 2 tests
test it_returns_two ... ok
test it_returns_six ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Tentu saja ini tidak sulit untuk dipahami.</p>
<p>Biasanya kita ingin menempatkan test yang kita buat di module mereka sendiri. Untuk melakukan hal ini, gunakan keyword <code>mod</code> dan tambahkan <code>#[cfg(test)]</code> di atasnya (ingat: <code>cfg</code> berarti &quot;configure&quot;/&quot;pengaturan&quot;). Anda juga perlu untuk selalu menuliskan <code>#[test]</code> di bagian atas setiap test. Ini karena nantinya di saat Anda sudah menginstall Rust, Anda bisa melakukan testing yang jauh lebih rumit. Anda bisa mejalankan satu test saja, atau semuanya, atau hanya beberapa saja. Juga jangan lupa untuk menuliskan <code>use super::*;</code> karena module test perlu menggunakan function-function di atasnya. Sekarang codenya menjadi seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_two() -&gt; i8 {
    2
}
fn return_six() -&gt; i8 {
    4 + return_two()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_returns_six() {
        assert_eq!(return_six(), 6)
    }
    #[test]
    fn it_returns_two() {
        assert_eq!(return_two(), 2);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="test-driven-development"><a class="header" href="#test-driven-development">Test-driven development</a></h3>
<p>Anda mungkin pernah mendengar tentang &quot;test-driven development&quot; di saat membaca tentang Rust atau bahasa pemrograman yang lain. Itu adalah salah satu cara untuk menulis program, dan beberapa orang menyukainya, sedangkan beberapa lagi lebih menyukai cara lain. &quot;Test-driven development&quot; berarti &quot;tulis testnya terlebih dahulu, lalu tulis codenya kemudian&quot;. Saat Anda menggunakan cara ini, Anda akan memiliki banyak test yang merepresentasikan apa yang Anda inginkan pada code yang Anda tuliskan nantinya. Kemudian Anda mulai menulis codenya, dan menjalankan testing untuk melihat apakah Anda melakukannya dengan benar. Kemudian test selalu ada untuk menunjukkan kepada Anda jika terjadi kesalahan saat Anda menambahkan dan menulis ulang code Anda. Ini cukup mudah di Rust karena compiler memberikan banyak informasi tentang apa yang harus diperbaiki. Mari kita tulis contoh kecil test-driven development dan kita lihat seperti apa bentuk codenya.</p>
<p>Mari bayangkan sebuah calculator yang mengambil inputan dari user. Ia bisa melakukan penjumlahan (+) dan juga pengurangan (-). Jika user menuliskan &quot;5 + 6&quot; ia semestinya mengembalikan 11, jika user menuliskan &quot;5 + 6 - 7&quot; maka semestinya mengembalikan 4, dst. Jadi, kita akan mulai dengan function testnya. Anda juga bisa melihat bahwa nama function di dalam test biasanya lumayan panjang. Ini dikarenakan kita ingin menjalankan begitu banyak test, dan kita ingin mengetahui test yang mana saja yang gagal.</p>
<p>Kita akan bayangkan ada satu function bernama <code>math()</code> yang akan melakukan apapun. Ia akan mengembalikan <code>i32</code> (kita tidak menggunakan floats). Karena ia perlu mengembalikan sesuatu, kita hanya akan mengembalikan <code>6</code> setiap saat. Kemudian kita menuliskan tiga buah function test. Dan tentu saja semuanya akan gagal. Sekarang codenya terlihat seperti berikut:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn math(input: &amp;str) -&gt; i32 {
    6
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Inilah informasi yang diberikan oleh test tersebut:</p>
<pre><code class="language-text">running 3 tests
test tests::one_minus_minus_one_is_two ... FAILED
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_plus_one_is_two ... FAILED
</code></pre>
<p>dan juga informasi <code>failure</code> lainnya yang menuliskan tentang <code>thread 'tests::one_plus_one_is_two' panicked at 'assertion failed: `(left == right)` </code>. Kita tidak perlu menuliskan itu semua di sini.</p>
<p>Sekarang pikirkan tentang bagaimana membuat kalkulator. Kita akan menerima angka apapun, dan simbol <code>+-</code>. Kita juga memperbolehkan penggunaan spasi, selain dari itu, karakter apapun tidak diperbolehkan. Jadi, mari kita mulai dengan <code>const</code> yang berisi semua valuenya. Kemudian kita menggunakan <code>.chars()</code> untuk melakukan iterasi berdasarkan karakter, dan <code>.all()</code> untuk memastikan karakter yang dimasukkan merupakan bagian dari karakter yang boleh dimasukkan.</p>
<p>Kemudian kita akan menambahkan test yang harus memunculkan panic. Untuk melakukan itu, tambahkan attribute <code>#[should_panic]</code>: sekarang jika ia panic, testnya akan berhasil.</p>
<p>Sekarang codenya menjadi seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;; // Jangan lupakan spasi pada bagian akhir dari kumpulan karakter

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }
    6 // kita tetap mengembalikan 6 untuk sekarang
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }

    #[test]
    #[should_panic]  // ini adalah test yang baru kita buat - seharusnya ia panic
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Sekarang, di saat kita menjalankan testnya kita mendapatkan hasil berikut:</p>
<pre><code class="language-text">running 4 tests
test tests::one_minus_two_is_minus_one ... FAILED
test tests::one_minus_minus_one_is_two ... FAILED
test tests::panics_when_characters_not_right ... ok
test tests::one_plus_one_is_two ... FAILED
</code></pre>
<p>Satu test berhasil! Function <code>math()</code> kita selanjutnya akan menerima inputan yang benar.</p>
<p>Langkah selanjutnya adalah menuliskan aplikasi kalkulator yang sebenarnya. Bagian menarik dari menuliskan testnya di awal adalah code dari programnya dibuat jauh setelahnya. Pertama, kita akan membuat aturan-aturan untuk kalkulator kita. Kita menginginkan aturan-aturan berikut:</p>
<ul>
<li>Semua space kosong akan dihapus. Ini mudah dilakukan menggunakan <code>.filter()</code></li>
<li>Inputnya harus diubah menjadi <code>Vec</code>. <code>+</code> tidak perlu dijadikan input. Namun di saat program melihat <code>+</code>, program harus tahu bahwa angka yang sebelumnya telah selesai. Contohnya, input <code>11+1</code> akan diperlakukan seperti ini: 1) Ada <code>1</code>, push angka tersebut ke string kosong. 2) Selanjutnya ada <code>1</code> lagi, push lagi ke dalam string (sekarang string tersebut adalah &quot;11&quot;). 3) Ada tanda <code>+</code>, program mengetahui bahwa string angka yang sebelumnya telah selesai. String tersebut dipush ke dalam vec, dan kemudian menghapus string tersebut.</li>
<li>Program kalkulator harus menghitung jumlah dari tanda <code>-</code>. Jika jumlahnya ganjil (1, 3, 5...), artinya itu adalah sebuah pengurangan. Jika ia berjumlah genap (2, 4, 6...) maka itu adalah sebuah penjumlahan. Sehingga &quot;1--9&quot; harus memberikan 10, bukan -8.</li>
<li>Program harus menghapus apapun setelah angka terakhir. <code>5+5+++++----</code> dibuat dari semua karakter yang berada di dalam <code>OKAY_CHARACTERS</code>, tapi ia haruslah mengembalikan <code>5+5</code>. Hal ini mudah dilakukan dengan menggunakan <code>.trim_end_matches()</code>, dimana ia bisa menghapus apapun (tuliskan karakter yang ingin dihapus) dibagian akhir <code>&amp;str</code>.</li>
</ul>
<p>(Ah ya, <code>.trim_end_matches()</code> dan <code>.trim_start_matches()</code> adalah method yang sama dengan <code>trim_right_matches()</code> dan <code>trim_left_matches()</code>. Namun kemudian orang-orang menyadari bahwa beberapa bahasa dituliskan dari kanan ke kiri (Persian, Hebrew, dll.) jadi kanan dan kiri dirasa kurang cocok untuk hal ini. Anda mungkin masih akan menemukan method lama tersebut di beberapa code, namun itu sebenarnya adalah code yang sama dengan yang versi end dan start.)</p>
<p>Jadinya kita akan membuat code yang kita buat lolos dari semua test. Setelah lolos dari test-test tersebut, kita bisa melakukan &quot;refactor&quot;. Refactor artinya membuat codenya menjadi lebih baik, biasanya dengan menggunakan struct, enum dan juga method. Inilah code yang ditulis agar kita bisa melewati semua test tersebut:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric())
    {
        panic!(&quot;Please only input numbers, +-, or spaces.&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;(); // Hapus + dan - yang ada pada bagian akhir, dan juga semua spasi
    let mut result_vec = vec![]; // Hasilnya akan masuk ke vec ini
    let mut push_string = String::new(); // Ini adalah string yang kita push setiap saat. Kita akan tetap menggunakannya di dalam loop.
    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !push_string.is_empty() { // Jika stringnya kosong, kita tidak menginginkan &quot;&quot; dipush ke dalam result_vec
                    result_vec.push(push_string.clone()); // Namun jika ia tidak kosong, semestinya ia adalah angka. Push ke dalam vec
                    push_string.clear(); // Kemudian clear stringnya
                }
            },
            '-' =&gt; { // Jika kita mendapatkan tanda -,
                if push_string.contains('-') || push_string.is_empty() { // periksa untuk mengetahui apakah ia kosong atau memiliki tanda -
                    push_string.push(character) // jika ya, maka push
                } else { // sebaliknya, ia tentunya berisi angka
                result_vec.push(push_string.clone()); // push angkanya ke dalam result_vec, clear dan kemudian push tanda -
                push_string.clear();
                push_string.push(character);
                }
            },
            number =&gt; { // number disini maksudnya adalah &quot;apapun yang match&quot;. kita menggunakan nama &quot;number disini&quot;
                if push_string.contains('-') { // kita mungkin saja memiliki beberapa karakter - untuk di push pertama kali
                    result_vec.push(push_string.clone());
                    push_string.clear();
                    push_string.push(number);
                } else { // Namun jika kita tidak melakukannya, itu berarti kita bisa push numbernya ke dalam push_string
                    push_string.push(number);
                }
            },
        }
    }
    result_vec.push(push_string); // Push untuk terakhir kalinya setelah loopnya selesai. Kita tidak memerlukan .clone() karena kita tidak memerlukannya lagi

    let mut total = 0; // Sekarang saatnya kita melakukan operasi matematika. Mulai dengan total
    let mut adds = true; // true = tambah, false = kurang
    let mut math_iter = result_vec.into_iter();
    while let Some(entry) = math_iter.next() { // lakukan iter pada semua itemnya
        if entry.contains('-') { // Jika ia memiliki karakter - , periksa apakah jumlahnya genap atau ganjil
            if entry.chars().count() % 2 == 1 {
                adds = match adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue; // ke item yang selanjutnya
            } else {
                continue;
            }
        }
        if adds == true {
            total += entry.parse::&lt;i32&gt;().unwrap(); // Jika tidak ada '-', ia semestinya adalah sebuah angka. Jadinya kita aman untuk melakukan unwrap
        } else {
            total -= entry.parse::&lt;i32&gt;().unwrap();
            adds = true;  // Setelah melakukan pengurangan, ubah kembali addsnya menjadi true.
        }
    }
    total // Akhrnya, return totalnya
}
   /// Kita akan menambahkan beberapa test untuk memastikan program kita telah berjalan dengan benar

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0); // Ini adalah test yang baru
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8); // Ini adalah test yang baru
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Dan sekarang semua testnya telah terlewati!</p>
<pre><code class="language-text">running 6 tests
test tests::one_minus_minus_one_is_two ... ok
test tests::nine_plus_nine_minus_nine_minus_nine_is_zero ... ok
test tests::one_minus_two_is_minus_one ... ok
test tests::eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end ... ok
test tests::one_plus_one_is_two ... ok
test tests::panics_when_characters_not_right ... ok

test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Anda bisa melihat bahwa ada proses &quot;bolak-balik&quot; di saat kita melakukan test-driven development. Kira-kira seperti ini:</p>
<ul>
<li>Pertama, kita tuliskan semua test yang terbersit di pikiran kita.</li>
<li>Kemudian kita mulai menuliskan codenya.</li>
<li>Di saat proses penulisan code, kita mendapatkan ide untuk menambahkan test-test baru.</li>
<li>Anda tambahkan lagi testnya, dan testnya terus bertambah seiring codenya bertambah. Semakin banyak test yang Anda miliki, semakin sering code Anda diperiksa.</li>
</ul>
<p>Tentu saja, test tidak memeriksa semuanya dan salah jika kita berpikir bahwa &quot;lolos di semua test = codenya sempurna&quot;. Tapi test sangatlah berguna di saat code kita mengalami perubahan. Apabila Anda mengubah codenya kemudian dan menjalankan testnya, jika ada salah satunya yang tidak bekerja maka kita akan tahu yang mana yang semestinya kita perbaiki.</p>
<p>Sekarang kita bisa melakukan refactor codenya sedikit demi sedikit. Salah satu cara yang baik untuk melakukan refactor adalah menggunakan clippy. Jika Anda menginstall Rust maka Anda bisa menuliskan perintah <code>cargo clippy</code>, dan jika Anda menggunakan Playground maka klik pada <code>TOOLS</code> dan pilih Clippy. Clippy melihat pada code yang kita buat dan memberikan kita tips untuk membuat codenya menjadi lebih sederhana. Code yang kita buat tidak memiliki kesalahan, namun kita bisa membuatnya menjadi lebih baik.</p>
<p>Clippy memberi tahu kita tentang dua hal:</p>
<pre><code class="language-text">warning: this loop could be written as a `for` loop
  --&gt; src/lib.rs:44:5
   |
44 |     while let Some(entry) = math_iter.next() { // Iter through the items
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for entry in math_iter`
   |
   = note: `#[warn(clippy::while_let_on_iterator)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#while_let_on_iterator

warning: equality checks against true are unnecessary
  --&gt; src/lib.rs:53:12
   |
53 |         if adds == true {
   |            ^^^^^^^^^^^^ help: try simplifying it as shown: `adds`
   |
   = note: `#[warn(clippy::bool_comparison)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison
</code></pre>
<p>Ini benar: <code>for entry in math_iter</code> lebih simple daripada <code>while let Some(entry) = math_iter.next()</code>. Dan sebuah loop <code>for</code> sebenarnya adalah sebuah iterator sehingga kita tidak punya alasan untuk menuliskan <code>.iter()</code>. Terima kasih, clippy! :D Dan juga kita tidak perlu untuk membuat <code>math_iter</code>: kita hanya perlu menuliskan <code>for entry in result_vec</code>.</p>
<p>Sekarang kita mulai refactor yang sesungguhnya. Alih-alih menggunakan variabel yang terpisah, kita akan membuat struct <code>Calculator</code>. Ia akan memiliki semua variabel yang kita gunakan. Kita akan mengubah dua nama untuk membuatnya menjadi jelas. <code>result_vec</code> akan menjadi <code>results</code>, dan <code>push_string</code> akan menjadi <code>current_input</code> (current berarti &quot;sekarang&quot;). Dan sejauh ini ia hanya memiliki satu method: new.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// üöß
#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Sekarang code kita menjadi agak panjang, namun menjadi lebih mudah untuk dibaca. Contohnya, <code>if adds</code> sekarang menjadi <code>if calculator.adds</code>, yang mana menjadi seperti membaca bahasa Inggris pada umumnya. Codenya menjadi seperti berikut:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }
}

const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                }
            },
            '-' =&gt; {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.current_input.push(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.current_input.clear();
                calculator.current_input.push(character);
                }
            },
            number =&gt; {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.current_input.clear();
                    calculator.current_input.push(number);
                } else {
                    calculator.current_input.push(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::&lt;i32&gt;().unwrap();
        } else {
            calculator.total -= entry.parse::&lt;i32&gt;().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Akhirnya kita menambahkan 2 method baru. Yang satu bernama <code>.clear()</code> dan melakukan clear terhadap <code>current_input()</code>. Yang satu lagi bernama <code>push_char()</code> dan melakukan push terhadap input ke dalam <code>current_input()</code>. Inilah code yang telah sepenuhnya direfactor:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct Calculator {
    results: Vec&lt;String&gt;,
    current_input: String,
    total: i32,
    adds: bool,
}

impl Calculator {
    fn new() -&gt; Self {
        Self {
            results: vec![],
            current_input: String::new(),
            total: 0,
            adds: true,
        }
    }

    fn clear(&amp;mut self) {
        self.current_input.clear();
    }

    fn push_char(&amp;mut self, character: char) {
        self.current_input.push(character);
    }
}

const OKAY_CHARACTERS: &amp;str = &quot;1234567890+- &quot;;

fn math(input: &amp;str) -&gt; i32 {
    if !input.chars().all(|character| OKAY_CHARACTERS.contains(character)) ||
       !input.chars().take(2).any(|character| character.is_numeric()) {
        panic!(&quot;Please only input numbers, +-, or spaces&quot;);
    }

    let input = input.trim_end_matches(|x| &quot;+- &quot;.contains(x)).chars().filter(|x| *x != ' ').collect::&lt;String&gt;();
    let mut calculator = Calculator::new();

    for character in input.chars() {
        match character {
            '+' =&gt; {
                if !calculator.current_input.is_empty() {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                }
            },
            '-' =&gt; {
                if calculator.current_input.contains('-') || calculator.current_input.is_empty() {
                    calculator.push_char(character)
                } else {
                calculator.results.push(calculator.current_input.clone());
                calculator.clear();
                calculator.push_char(character);
                }
            },
            number =&gt; {
                if calculator.current_input.contains('-') {
                    calculator.results.push(calculator.current_input.clone());
                    calculator.clear();
                    calculator.push_char(number);
                } else {
                    calculator.push_char(number);
                }
            },
        }
    }
    calculator.results.push(calculator.current_input);

    for entry in calculator.results {
        if entry.contains('-') {
            if entry.chars().count() % 2 == 1 {
                calculator.adds = match calculator.adds {
                    true =&gt; false,
                    false =&gt; true
                };
                continue;
            } else {
                continue;
            }
        }
        if calculator.adds {
            calculator.total += entry.parse::&lt;i32&gt;().unwrap();
        } else {
            calculator.total -= entry.parse::&lt;i32&gt;().unwrap();
            calculator.adds = true;
        }
    }
    calculator.total
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_plus_one_is_two() {
        assert_eq!(math(&quot;1 + 1&quot;), 2);
    }
    #[test]
    fn one_minus_two_is_minus_one() {
        assert_eq!(math(&quot;1 - 2&quot;), -1);
    }
    #[test]
    fn one_minus_minus_one_is_two() {
        assert_eq!(math(&quot;1 - -1&quot;), 2);
    }
    #[test]
    fn nine_plus_nine_minus_nine_minus_nine_is_zero() {
        assert_eq!(math(&quot;9+9-9-9&quot;), 0);
    }
    #[test]
    fn eight_minus_nine_plus_nine_is_eight_even_with_characters_on_the_end() {
        assert_eq!(math(&quot;8  - 9     +9-----+++++&quot;), 8);
    }
    #[test]
    #[should_panic]
    fn panics_when_characters_not_right() {
        math(&quot;7 + seven&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Mungkin ini cukup baik untuk sekarang ini. Kita bisa menuliskan lebih banyak method, namun baris code seperti <code>calculator.results.push(calculator.current_input.clone());</code> sudah sangat cukup jelas. Refactor yang baik adalah jika Anda masih bisa dengan mudah membaca codenya setelah Anda telah selesai merefactornya. Anda tentunya tidak ingin melakukan refactor hanya untuk membuat codenya terlihat pendek: contohnya, <code>clc.clr()</code> lebih buruk dibanding <code>calculator.clear()</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="Chapter_58.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="Chapter_60.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="Chapter_58.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="Chapter_60.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
