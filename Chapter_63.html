<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> Writing macros - Easy Rust</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Chapter_0.html"><strong aria-hidden="true">1.</strong> Update</a></li><li class="chapter-item expanded "><a href="Chapter_1.html"><strong aria-hidden="true">2.</strong> Penyelarasan Isi &amp; Translasi</a></li><li class="chapter-item expanded "><a href="Chapter_2.html"><strong aria-hidden="true">3.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="Chapter_3.html"><strong aria-hidden="true">4.</strong> Who am I?</a></li><li class="chapter-item expanded "><a href="Chapter_4.html"><strong aria-hidden="true">5.</strong> Catatan dari translator</a></li><li class="chapter-item expanded "><a href="Chapter_5.html"><strong aria-hidden="true">6.</strong> Writing Rust in Easy English</a></li><li class="chapter-item expanded "><a href="Chapter_6.html"><strong aria-hidden="true">7.</strong> Rust Playground</a></li><li class="chapter-item expanded "><a href="Chapter_7.html"><strong aria-hidden="true">8.</strong> üöß and ‚ö†Ô∏è</a></li><li class="chapter-item expanded "><a href="Chapter_8.html"><strong aria-hidden="true">9.</strong> Comments</a></li><li class="chapter-item expanded "><a href="Chapter_9.html"><strong aria-hidden="true">10.</strong> Types</a></li><li class="chapter-item expanded "><a href="Chapter_10.html"><strong aria-hidden="true">11.</strong> Type inference</a></li><li class="chapter-item expanded "><a href="Chapter_11.html"><strong aria-hidden="true">12.</strong> Printing 'hello, world!'</a></li><li class="chapter-item expanded "><a href="Chapter_12.html"><strong aria-hidden="true">13.</strong> Display and debug</a></li><li class="chapter-item expanded "><a href="Chapter_13.html"><strong aria-hidden="true">14.</strong> Mutability (changing)</a></li><li class="chapter-item expanded "><a href="Chapter_14.html"><strong aria-hidden="true">15.</strong> The stack, the heap, and pointers</a></li><li class="chapter-item expanded "><a href="Chapter_15.html"><strong aria-hidden="true">16.</strong> More about printing</a></li><li class="chapter-item expanded "><a href="Chapter_16.html"><strong aria-hidden="true">17.</strong> Strings</a></li><li class="chapter-item expanded "><a href="Chapter_17.html"><strong aria-hidden="true">18.</strong> const and static</a></li><li class="chapter-item expanded "><a href="Chapter_18.html"><strong aria-hidden="true">19.</strong> More on references</a></li><li class="chapter-item expanded "><a href="Chapter_19.html"><strong aria-hidden="true">20.</strong> Mutable references</a></li><li class="chapter-item expanded "><a href="Chapter_20.html"><strong aria-hidden="true">21.</strong> Giving references to functions</a></li><li class="chapter-item expanded "><a href="Chapter_21.html"><strong aria-hidden="true">22.</strong> Copy types</a></li><li class="chapter-item expanded "><a href="Chapter_22.html"><strong aria-hidden="true">23.</strong> Collection types</a></li><li class="chapter-item expanded "><a href="Chapter_23.html"><strong aria-hidden="true">24.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="Chapter_24.html"><strong aria-hidden="true">25.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="Chapter_25.html"><strong aria-hidden="true">26.</strong> Control flow</a></li><li class="chapter-item expanded "><a href="Chapter_26.html"><strong aria-hidden="true">27.</strong> Structs</a></li><li class="chapter-item expanded "><a href="Chapter_27.html"><strong aria-hidden="true">28.</strong> Enums</a></li><li class="chapter-item expanded "><a href="Chapter_28.html"><strong aria-hidden="true">29.</strong> Loops</a></li><li class="chapter-item expanded "><a href="Chapter_29.html"><strong aria-hidden="true">30.</strong> Implementing structs and enums</a></li><li class="chapter-item expanded "><a href="Chapter_30.html"><strong aria-hidden="true">31.</strong> Destructuring</a></li><li class="chapter-item expanded "><a href="Chapter_31.html"><strong aria-hidden="true">32.</strong> References and the dot operator</a></li><li class="chapter-item expanded "><a href="Chapter_32.html"><strong aria-hidden="true">33.</strong> Generics</a></li><li class="chapter-item expanded "><a href="Chapter_33.html"><strong aria-hidden="true">34.</strong> Option and Result</a></li><li class="chapter-item expanded "><a href="Chapter_34.html"><strong aria-hidden="true">35.</strong> Other collections</a></li><li class="chapter-item expanded "><a href="Chapter_35.html"><strong aria-hidden="true">36.</strong> The ? operator</a></li><li class="chapter-item expanded "><a href="Chapter_36.html"><strong aria-hidden="true">37.</strong> Traits</a></li><li class="chapter-item expanded "><a href="Chapter_37.html"><strong aria-hidden="true">38.</strong> Chaining methods</a></li><li class="chapter-item expanded "><a href="Chapter_38.html"><strong aria-hidden="true">39.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="Chapter_39.html"><strong aria-hidden="true">40.</strong> Closures</a></li><li class="chapter-item expanded "><a href="Chapter_40.html"><strong aria-hidden="true">41.</strong> The dbg! macro and .inspect</a></li><li class="chapter-item expanded "><a href="Chapter_41.html"><strong aria-hidden="true">42.</strong> Types of &amp;str</a></li><li class="chapter-item expanded "><a href="Chapter_42.html"><strong aria-hidden="true">43.</strong> Lifetimes</a></li><li class="chapter-item expanded "><a href="Chapter_43.html"><strong aria-hidden="true">44.</strong> Interior mutability</a></li><li class="chapter-item expanded "><a href="Chapter_44.html"><strong aria-hidden="true">45.</strong> Cow</a></li><li class="chapter-item expanded "><a href="Chapter_45.html"><strong aria-hidden="true">46.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="Chapter_46.html"><strong aria-hidden="true">47.</strong> The todo! macro</a></li><li class="chapter-item expanded "><a href="Chapter_47.html"><strong aria-hidden="true">48.</strong> Rc</a></li><li class="chapter-item expanded "><a href="Chapter_48.html"><strong aria-hidden="true">49.</strong> Multiple threads</a></li><li class="chapter-item expanded "><a href="Chapter_49.html"><strong aria-hidden="true">50.</strong> Closures in functions</a></li><li class="chapter-item expanded "><a href="Chapter_50.html"><strong aria-hidden="true">51.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="Chapter_51.html"><strong aria-hidden="true">52.</strong> Arc</a></li><li class="chapter-item expanded "><a href="Chapter_52.html"><strong aria-hidden="true">53.</strong> Channels</a></li><li class="chapter-item expanded "><a href="Chapter_53.html"><strong aria-hidden="true">54.</strong> Reading Rust documentation</a></li><li class="chapter-item expanded "><a href="Chapter_54.html"><strong aria-hidden="true">55.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="Chapter_55.html"><strong aria-hidden="true">56.</strong> Box</a></li><li class="chapter-item expanded "><a href="Chapter_56.html"><strong aria-hidden="true">57.</strong> Box around traits</a></li><li class="chapter-item expanded "><a href="Chapter_57.html"><strong aria-hidden="true">58.</strong> Default and the builder pattern</a></li><li class="chapter-item expanded "><a href="Chapter_58.html"><strong aria-hidden="true">59.</strong> Deref and DerefMut</a></li><li class="chapter-item expanded "><a href="Chapter_59.html"><strong aria-hidden="true">60.</strong> Crates and modules</a></li><li class="chapter-item expanded "><a href="Chapter_60.html"><strong aria-hidden="true">61.</strong> Testing</a></li><li class="chapter-item expanded "><a href="Chapter_61.html"><strong aria-hidden="true">62.</strong> External crates</a></li><li class="chapter-item expanded "><a href="Chapter_62.html"><strong aria-hidden="true">63.</strong> A tour of the standard library</a></li><li class="chapter-item expanded "><a href="Chapter_63.html" class="active"><strong aria-hidden="true">64.</strong> Writing macros</a></li><li class="chapter-item expanded "><a href="Chapter_64.html"><strong aria-hidden="true">65.</strong> cargo</a></li><li class="chapter-item expanded "><a href="Chapter_65.html"><strong aria-hidden="true">66.</strong> Taking user input</a></li><li class="chapter-item expanded "><a href="Chapter_66.html"><strong aria-hidden="true">67.</strong> Using files</a></li><li class="chapter-item expanded "><a href="Chapter_67.html"><strong aria-hidden="true">68.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="Chapter_68.html"><strong aria-hidden="true">69.</strong> The end?</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Easy Rust</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="writing-macros"><a class="header" href="#writing-macros">Writing macros</a></h2>
<p>Membuat macro bisa menjadi hal yang rumit. Anda hampir tidak perlu untuk membuatnya, namun terkadang Anda mungkin ingin membuatnya karena hal ini menyenangkan meskipun cukup menantang. Membuat macro sangatlah menarik karena bisa dikatakan bahwa membuat macro ini merupakan bahasa yang hampir berbeda. Untuk membuatnya, Anda sebenarnya perlu menggunakan macro lain yang bernama <code>macro_rules!</code>. Kemudian Anda menambahkan nama macro Anda dan block <code>{}</code>. Di dalamnya ada semacam statement <code>match</code>.</p>
<p>Contoh di bawah ini hanya memerlukan <code>()</code>, kemudian hanya me-return 6:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! give_six {
    () =&gt; {
        6
    };
}

fn main() {
    let six = give_six!();
    println!(&quot;{}&quot;, six);
}
</code></pre></pre>
<p>Tapi ia sama sekali bukan statement <code>match</code>, karena macro sebenarnya tidak meng-compile apapun. Ia mhanya mengambil input dan memberikan output. Kemudian compiler memeriksa untuk melihat apakah macro rulenya masuk akal. Itulah sebabnya mengapa macro seperti &quot;code yang menuliskan code&quot;. Anda akan mengingat bahwa sebuah statement <code>match</code> perlu untuk me-return type yang sama, sehingga code di bawah ini tidak akan berjalan:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
// ‚ö†Ô∏è
    let my_number = 10;
    match my_number {
        10 =&gt; println!(&quot;You got a ten&quot;),
        _ =&gt; 10,
    }
}
</code></pre></pre>
<p>Compiler akan memberikan pesan teguran bahwa Anda ingin me-return <code>()</code> di satu arm, dan me-return <code>i32</code> di arm yang lainnya.</p>
<pre><code class="language-text">error[E0308]: `match` arms have incompatible types
 --&gt; src\main.rs:5:14
  |
3 | /     match my_number {
4 | |         10 =&gt; println!(&quot;You got a ten&quot;),
  | |               ------------------------- this is found to be of type `()`
5 | |         _ =&gt; 10,
  | |              ^^ expected `()`, found integer
6 | |     }
  | |_____- `match` arms have incompatible types
</code></pre>
<p>Namun macro tidak peduli tentang itu, karena ia hanya memberikan output. Ia bukanlah compiler - ia hanyalah code yang dilandasi oleh code yang lain. Sehingga Anda bisa melakukan hal seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! six_or_print {
    (6) =&gt; {
        6
    };
    () =&gt; {
        println!(&quot;You didn't give me 6.&quot;);
    };
}

fn main() {
    let my_number = six_or_print!(6);
    six_or_print!();
}
</code></pre></pre>
<p>Semuanya berjalan normal, dan hasil cetaknya adalah <code>You didn't give me 6.</code>. Anda juga bisa melihat bahwa itu bukanlah arm yang ada pada match karena disitu tidak ada case <code>_</code>. Kita hanya bisa memberikannya <code>(6)</code>, atau <code>()</code>. Selain daripada itu akan membuat error. Dan angka <code>6</code> yang kita berikan itu pun sebenarnya bukanlah <code>i32</code>, ia hanyalah inputan 6. Anda sebenarnya bisa mengatur apapun sebagai input untuk macro, karena ia hanya melihat input untuk melihat apa yang didapatkannya. Contohnya:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! might_print {
    (THis is strange input ÌïòÌïò„ÅØ„ÅØÂìàÂìà but it still works) =&gt; {
        println!(&quot;You guessed the secret message!&quot;)
    };
    () =&gt; {
        println!(&quot;You didn't guess it&quot;);
    };
}

fn main() {
    might_print!(THis is strange input ÌïòÌïò„ÅØ„ÅØÂìàÂìà but it still works);
    might_print!();
}
</code></pre></pre>
<p>Jadinya, macro aneh yang kita buat ini hanya memberikan respond pada dua hal: <code>()</code> dan <code>(THis is strange input ÌïòÌïò„ÅØ„ÅØÂìàÂìà but it still works)</code>. Tidak ada selain itu. Hasil cetaknya adalah:</p>
<pre><code class="language-text">You guessed the secret message!
You didn't guess it
</code></pre>
<p>Jadi, macro itu sendiri tepatnya bukanlah syntax yang umumnya ada pada Rust. Namun macro juga bisa memahami type yang berbeda dari input yang Anda berikan. Lihatlah contoh ini:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! might_print {
    ($input:expr) =&gt; {
        println!(&quot;You gave me: {}&quot;, $input);
    }
}

fn main() {
    might_print!(6);
}
</code></pre></pre>
<p>Ia akan mencetak <code>You gave me: 6</code>. Bagian <code>$input:expr</code> adalah bagian yang penting. Ini berarti &quot;untuk sebuah expression, berikan ia nama variabel $input&quot;. Di dalam macro, variabel dimulai dengan <code>$</code>. Di dalam macro ini, jika Anda memberikan satu expression, ia akan mencetaknya. Mari kita coba lagi:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! might_print {
    ($input:expr) =&gt; {
        println!(&quot;You gave me: {:?}&quot;, $input); // Sekarang kita menggunakan {:?} karena kita akan memberikannya jenis expression yang berbeda
    }
}

fn main() {
    might_print!(()); // berikan ia ()
    might_print!(6); // berikan ia 6
    might_print!(vec![8, 9, 7, 10]); // berikan ia vec
}
</code></pre></pre>
<p>Hasil cetaknya adalah:</p>
<pre><code class="language-text">You gave me: ()
You gave me: 6
You gave me: [8, 9, 7, 10]
</code></pre>
<p>Perhatikan juga bahwa kita menuliskan <code>{:?}</code>, namun ia tidak memeriksa apakah <code>&amp;input</code> mengimplementasikan <code>Debug</code>. Ia hanya akan menuliskan code dan mencoba membuatnya ter-compile, dan jika tidak maka ia akan memberikan error.</p>
<p>Jadi apa saja yang bisa dilihat oleh macro selain <code>expr</code>? Mereka adalah: <code>block | expr | ident | item | lifetime | literal  | meta | pat | path | stmt | tt | ty | vis</code>. Ini adalah bagian yang rumit. Anda bisa melihat apa arti dari masing-masing macro attribute tersebut <a href="https://doc.rust-lang.org/beta/reference/macros-by-example.html">di sini</a>, yang mana laman tersebut menjelaskan:</p>
<pre><code class="language-text">item: an Item
block: a BlockExpression
stmt: a Statement without the trailing semicolon (except for item statements that require semicolons)
pat: a Pattern
expr: an Expression
ty: a Type
ident: an IDENTIFIER_OR_KEYWORD
path: a TypePath style path
tt: a TokenTree (a single token or tokens in matching delimiters (), [], or {})
meta: an Attr, the contents of an attribute
lifetime: a LIFETIME_TOKEN
vis: a possibly empty Visibility qualifier
literal: matches -?LiteralExpression
</code></pre>
<p>Ada situs bagus lainnya yang bernama cheats.rs yang menjelaskan semua macro attribute tersebut. Anda bisa membacanya penjelasannya <a href="https://cheats.rs/#macros-attributes">di sini</a> dan disana ada contoh untuk masing-masing macro attribute yang disebutkan itu.</p>
<p>Namun, untuk kebanyakan macro Anda biasanya akan menggunakan <code>expr</code>, <code>ident</code>, dan <code>tt</code>. <code>ident</code> berarti adalah identifier dan ia berguna untuk nama variabel atau nama function. <code>tt</code> adalah token tree dan semacamnya yang berarti itu adalah semua jenis inputan. Mari kita coba buat macro sederhana dengan kedua macro attribute tersebut.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! check {
    ($input1:ident, $input2:expr) =&gt; {
        println!(
            &quot;Is {:?} equal to {:?}? {:?}&quot;,
            $input1,
            $input2,
            $input1 == $input2
        );
    };
}

fn main() {
    let x = 6;
    let my_vec = vec![7, 8, 9];
    check!(x, 6);
    check!(my_vec, vec![7, 8, 9]);
    check!(x, 10);
}
</code></pre></pre>
<p>Jadi, macro di atas akan mengambil satu <code>ident</code> (seperti nama variabel) dan sebuah expression, dan melihat apakah <code>ident</code> dan <code>expr</code> tersebut sama. Hasil cetaknya adalah:</p>
<pre><code class="language-text">Is 6 equal to 6? true
Is [7, 8, 9] equal to [7, 8, 9]? true
Is 6 equal to 10? false
</code></pre>
<p>Dan ini adalah satu macro yang mengambil <code>tt</code> dan mencetaknya. Macro tersebut akan menggunakan macro lainnya yang bernama <code>stringify!</code> untuk membuatnya menjadi string terlebih dahulu.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! print_anything {
    ($input:tt) =&gt; {
        let output = stringify!($input);
        println!(&quot;{}&quot;, output);
    };
}

fn main() {
    print_anything!(ththdoetd);
    print_anything!(87575oehq75onth);
}
</code></pre></pre>
<p>Hasil cetaknya adalah:</p>
<pre><code class="language-text">ththdoetd
87575oehq75onth
</code></pre>
<p>Tetapi ia tidak akan mencetak apapun apabila kita memberikan sesuatu dengan spasi, koma, dll. Ia akan mengira bahwa kita memberikannya lebih dari satu item atau informasi tambahan, sehingga ia akan menjadi bingung.</p>
<p>Di sinilah macro mulai menjadi sulit untuk dibuat.</p>
<p>Untuk memberi macro lebih dari satu item, kita perlu menggunakan syntax yang berbeda. Alih-alih menggunakan <code>$input</code>, kita akan menggunakan <code>$($input1),*</code>. Ini berarti nol, satu atau lebih dari satu (inilah apa yang dimaksud dengan *), dipisahkan dengan koma. Jika Anda menginginkan satu atau lebih, gunakan <code>+</code> alih-alih menggunakan <code>*</code>.</p>
<p>Sekarang macro kita menjadi seperti ini:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! print_anything {
    ($($input1:tt),*) =&gt; {
        let output = stringify!($($input1),*);
        println!(&quot;{}&quot;, output);
    };
}


fn main() {
    print_anything!(ththdoetd, rcofe);
    print_anything!();
    print_anything!(87575oehq75onth, ntohe, 987987o, 097);
}
</code></pre></pre>
<p>Sehingga ia akan mengambil apapun token tree yang dipisahkan dengan koma, dan menggunakan <code>stringify!</code> untuk membuatnya menjadi string, kemudian mencetaknya. Hasilnya adalah sebagai berikut:</p>
<pre><code class="language-text">ththdoetd, rcofe

87575oehq75onth, ntohe, 987987o, 097
</code></pre>
<p>Jika kita menggunakan <code>+</code> menggantikan <code>*</code>, ia akan memberikan error, karena terkadang kita tidak memberikan input. Sehingga <code>*</code> adalah pilihan yang lebih aman.</p>
<p>Jadi, sekarang kita bisa mulai melihat power dari macro. Pada contoh kali ini, kita sebenarnya bisa membuat function kita sendiri:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! make_a_function {
    ($name:ident, $($input:tt),*) =&gt; { // Pertama, Anda berikan ia satu nama untuk function tersebut, lalu kemudian memeriksa yang lainnya
        fn $name() {
            let output = stringify!($($input),*); // Ia membuat segala sesuatunya menjadi string
            println!(&quot;{}&quot;, output);
        }
    };
}


fn main() {
    make_a_function!(print_it, 5, 5, 6, I); // Kita ingin membuat function bernama print_it() yang mencetak apapun yang kita berikan
    print_it();
    make_a_function!(say_its_nice, this, is, really, nice); // Yang dilakukan pada bagian ini juga sama, namun kita mengubah nama functionnya
    say_its_nice();
}
</code></pre></pre>
<p>Hasil cetaknya adalah:</p>
<pre><code class="language-text">5, 5, 6, I
this, is, really, nice
</code></pre>
<p>Jadi sekarang kita bisa mulai memahami macro lainnya. Anda bisa melihat bahwa beberapa macro yang pernah kita gunakan ternyata sangatlah sederhana. Salah satu contohnya adalah <code>write!</code> yang biasa kita gunakan untuk menulis ke file:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! write {
    ($dst:expr, $($arg:tt)*) =&gt; ($dst.write_fmt($crate::format_args!($($arg)*)))
}
<span class="boring">}
</span></code></pre></pre>
<p>Jadi untuk menggunakannya, Anda perlu memasukkan ini:</p>
<ul>
<li>sebuah expression (<code>expr</code>) yang mengambil nama variabel <code>$dst</code>.</li>
<li>apapu yang ada setelahnya. Jika disitu tertulis <code>$arg:tt</code> maka ia hanya bisa mengambil satu argument, tapi karena disitu tertulis <code>$($arg:tt)*</code> ia akan mengambil nol, satu, atau banyak argument.</li>
</ul>
<p>Kemudian ia mengambil <code>$dst</code> dan menggunakan method <code>write_fmt</code> pada <code>$dst</code> tersebut. Di dalamnya, ia menggunakan macro lainnya yang bernama <code>format_args!</code> yang mengambil semua <code>$($arg)*</code>, atau semua argument yang kita masukkan.</p>
<p>Sekarang saatnya kita melihat isi dari macro <code>todo!</code>. Macro ini digunakan ketika Anda menginginkan programnya tercompile namun beberapa bagian codenya belum dituliskan. Berikut isi dari macro tersebut:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! todo {
    () =&gt; (panic!(&quot;not yet implemented&quot;));
    ($($arg:tt)+) =&gt; (panic!(&quot;not yet implemented: {}&quot;, $crate::format_args!($($arg)+)));
}
<span class="boring">}
</span></code></pre></pre>
<p>Macro ini memiliki dua opsi: Anda bisa memasukkan <code>()</code>, atau beberapa token tree (<code>tt</code>).</p>
<ul>
<li>Jika Anda memasukkan <code>()</code>, ia akan menggunakan <code>panic!</code> dengan sebuah pesan. Jadi sebenarnya Anda bisa menulis <code>panic!(&quot;not yet implemented&quot;)</code> untuk menggantikan <code>todo!</code> dan ia akan melakukan hal yang sama.</li>
<li>Jika Anda memasukkan beberapa argument, ia akan mencoba untuk mencetaknya. Anda bisa melihat hal yang sama di dalam macro <code>format_args!</code> macro, yang mana bekerja seperti <code>println!</code>.</li>
</ul>
<p>Jadi jika Anda menuliskan ini, ia pun juga akan berjalan:</p>
<pre><pre class="playground"><code class="language-rust">fn not_done() {
    let time = 8;
    let reason = &quot;lack of time&quot;;
    todo!(&quot;Not done yet because of {}. Check back in {} hours&quot;, reason, time);
}

fn main() {
    not_done();
}
</code></pre></pre>
<p>Hasilnya adalah:</p>
<pre><code class="language-text">thread 'main' panicked at 'not yet implemented: Not done yet because of lack of time. Check back in 8 hours', src/main.rs:4:5
</code></pre>
<p>Di dalam sebuah macro, Anda bahkan bisa memanggil macro yang sama. Seperti ini contohnya:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! my_macro {
    () =&gt; {
        println!(&quot;Let's print this.&quot;);
    };
    ($input:expr) =&gt; {
        my_macro!();
    };
    ($($input:expr),*) =&gt; {
        my_macro!();
    }
}

fn main() {
    my_macro!(vec![8, 9, 0]);
    my_macro!(toheteh);
    my_macro!(8, 7, 0, 10);
    my_macro!();
}
</code></pre></pre>
<p>Macro ini mengambil <code>()</code>, atau satu expression, atau banyak expression. Tapi ia akan mengabaikan semua expression yang diberikan, tidak peduli apapun yang Anda masukkan, dan kita hanya bisa memanggil <code>my_macro!</code> dengan <code>()</code>. Sehingga outputnya adalah <code>Let's print this</code> yang dicetak sebanyak empat kali.</p>
<p>Anda bisa melihat hal yang sama pada macro <code>dbg!</code>, yang mana ia memanggil dirinya sendiri.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! dbg {
    () =&gt; {
        $crate::eprintln!(&quot;[{}:{}]&quot;, $crate::file!(), $crate::line!()); //$crate artinya adalah crate yang berada di dalamnya.
    };
    ($val:expr) =&gt; {
        // Penggunaan `match` di sini memanglah disengaja karena ia akan memengaruhi lifetime
        // https://stackoverflow.com/a/48732525/1063961
        match $val {
            tmp =&gt; {
                $crate::eprintln!(&quot;[{}:{}] {} = {:#?}&quot;,
                    $crate::file!(), $crate::line!(), $crate::stringify!($val), &amp;tmp);
                tmp
            }
        }
    };
    // Koma yang mengikuti sebuah argument (koma yang ditulis setelah ditulisnya satu argument, tanpa ada argument lanjutan) akan diabaikan
    ($val:expr,) =&gt; { $crate::dbg!($val) };
    ($($val:expr),+ $(,)?) =&gt; {
        ($($crate::dbg!($val)),+,)
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>(<code>eprintln!</code> sama seperti <code>println!</code>. Yang membedakannya adalah ia akan mencetak ke <code>io::stderr</code>, bukan mencetak ke <code>io::stdout</code> seperti yang dilakukan oleh <code>println!</code>. Ada juga <code>eprint!</code> yang tidak menambahkan baris baru)</p>
<p>Jadinya, kita akan mencoba macro tersebut.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    dbg!();
}
</code></pre></pre>
<p>Macro tersebut cocok dengan arm yang pertama, sehingga ia akan mencetak nama file dan nomor line dengan menggunakan macro <code>file!</code> dan <code>line!</code>. Hasil cetaknya adalah <code>[src/main.rs:2]</code>.</p>
<p>Akan kita coba dengan vec:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    dbg!(vec![8, 9, 10]);
}
</code></pre></pre>
<p>Ini cocok dengan arm yang selanjutnya (arm kedua), karena ia hanya memiliki satu expression. Ia akan memanggil input <code>tmp</code> dan menggunakan code: <code> $crate::eprintln!(&quot;[{}:{}] {} = {:#?}&quot;, $crate::file!(), $crate::line!(), $crate::stringify!($val), &amp;tmp);</code>. Sehingga ia akan mencetak dengan macro <code>file!</code> dan <code>line!</code>, kemudian membuat <code>$val</code> menjadi <code>String</code>, dan juga pretty print <code>{:#?}</code> untuk <code>tmp</code>. Sehingga inputan vec kita itu akan memberi output seperti ini:</p>
<pre><code class="language-text">[src/main.rs:2] vec![8, 9, 10] = [
    8,
    9,
    10,
]
</code></pre>
<p>Dan selebihnya, ia hanya memanggil <code>dbg!</code> pada dirinya sendiri meskipun Anda memasukkan koma tambahan.</p>
<p>Sebagaimana yang bisa kita lihat, macro sangatlah rumit! Biasanya, kita hanya ingin menggunakan macro yang melakukan sesuatu secara otomatis yang mana tidak bisa dilakukan oleh function sederhana. Cara terbaik untuk mempelajari macro adalah melihat pada contoh macro yang lainnya. Tidak banyak orang yang bisa menulis macro dengan cepat tanpa mendapatkan masalah apapun. Jadi jangan berpikir bahwa Anda perlu mengetahui semua tentang macro untuk mengetahui cara membuat program di Rust. Namun jika Anda membaca macro lainnya yang sudah ada, dan mencoba mengubahnya sedikit-sedikit, Anda bisa dengan mudah meminjam &quot;kekuatan&quot; dari macro ini. Dan kemudian Anda mungkin mulai merasa nyaman untuk menulis macro Anda sendiri.</p>
<h1 id="part-2---rust-on-your-computer"><a class="header" href="#part-2---rust-on-your-computer">Part 2 - Rust on your computer</a></h1>
<p>Anda bisa melihat bahwa kita bisa mempelajari hampir semua yang ada di Rust hanya dengan menggunakan Playground. Tapi jika Anda mempelajari semuanya sejauh  ini, mungkin saja Anda menginginkan Rust di komputer Anda sekarang. Selalu ada hal-hal yang tidak bisa Anda lakukan di Playground, misalnya menggunakan file atau code yang memiliki lebih dari satu file. Beberapa hal lain yang membuat Anda membutuhkan Rust di komputer Anda adalah untuk mengambil inputan dari user dan juga flag. Namun hal terpenting yang bisa dilakukan oleh Rust yang terinstall di komputer adalah Anda bisa menggunakan crate. Kita telah mempelajari tentang crate, namun di Playground kita hanya bisa menggunakan crate-crate yang paling populer saja. Jadi dengan Rust yang telah terinstall di komputer kita bisa menggunakan crate apapun untuk program yang kita buat.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="Chapter_62.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="Chapter_64.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="Chapter_62.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="Chapter_64.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
